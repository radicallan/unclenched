
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Spirit Board — Mobile (iPhone, Precision v2)</title>
<style>
  :root{--bg:#0b0d12;--panel:#0f121a;--ink:#e7ebf2;--muted:#96a0b1;--accent:#7ae1ff;--good:#7bf59a;--warn:#ffd166;--bad:#ff6b6b}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:16px/1.4 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial}
  html,body{overscroll-behavior:auto; touch-action:auto}
  .wrap{display:flex;flex-direction:column;min-height:100vh}
  header{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:10px;background:#0f121a;border-bottom:1px solid #1b2330;position:sticky;top:0;z-index:10}
  header .sp{flex:1}
  button{appearance:none;border:1px solid #2a3a58;background:#0f1726;color:var(--ink);padding:10px 12px;border-radius:12px}
  button:active{transform:scale(0.98)}
  label{display:inline-flex;align-items:center;gap:6px}
  select, input[type="range"]{accent-color:#2de2ff;background:#0f1726;color:var(--ink);border:1px solid #2a3a58;border-radius:10px;padding:6px 8px}
  #status{color:#a9b3c6}
  #stage{position:relative;flex:1;min-height:52vh}
  #cv{position:absolute;inset:0;display:block;width:100%;height:100%;touch-action:none;-webkit-user-select:none;user-select:none}
  #log{min-height:120px;max-height:38vh;overflow:auto;padding:10px;background:#0a0f16;border-top:1px solid #1b2330;font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .small{font-size:13px;color:#97a1b1}
  .pill{padding:4px 8px;border-radius:999px;border:1px solid #2a3a58;background:#0f1726}
  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#101826;border:1px solid #29405f;color:#eaf4ff;padding:8px 12px;border-radius:10px;opacity:0;transition:opacity .2s}
  .toast.show{opacity:1}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="row" style="width:100%">
      <button id="btnStart" type="button">Invite</button>
      <button id="btnStop" type="button">Goodbye</button>
      <button id="btnReset" type="button">Reset</button>
      <button id="btnCenter" type="button">Center</button>
      <div class="sp"></div>
      <span id="status">Idle • 0 chars</span>
    </div>
    <div class="row" style="width:100%">
      <label><input type="checkbox" id="chkBlind"> Blind</label>
      <label><input type="checkbox" id="chkSeal"> Seal</label>
      <label><input type="checkbox" id="chkShuffle"> Shuffle</label>
      <label><input type="checkbox" id="chkDebug"> Debug view</label>
      <label>Gain <input type="range" id="rngGain" min="0.6" max="2.4" step="0.1" value="1.6"></label>
      <label>Commit
        <select id="selMode">
          <option value="dwell">Dwell (safe)</option>
          <option value="exit" selected>Exit (very safe)</option>
          <option value="press">Press (double‑tap)</option>
        </select>
      </label>
      <label>Dwell <input type="range" id="rngDwell" min="400" max="1500" step="50" value="800"></label>
      <label>Spacing <input type="range" id="rngSpace" min="1.0" max="2.2" step="0.1" value="1.6"></label>
      <span class="pill" id="badgeReady" style="display:none">READY</span>
      <button id="btnExport" type="button">Export</button>
    </div>
    <div class="small">Exit mode: enter a letter → wait for the ring to fill → <b>slide off</b> the tile to commit. Use Debug view while testing (overrides Blind/Seal in the log).</div>
  </header>

  <div id="stage"><canvas id="cv"></canvas></div>
  <div id="log">(nothing yet)</div>
  <div id="toast" class="toast">Committed</div>
</div>

<script>
(function(){
  // ----- Helpers -----
  const $=s=>document.querySelector(s);
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  const cv = $('#cv'); const ctx = cv.getContext('2d');
  const statusEl = $('#status'); const logEl = $('#log'); const badgeReady = $('#badgeReady'); const toastEl = $('#toast');

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  function toast(msg){
    toastEl.textContent=msg; toastEl.classList.add('show');
    clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.classList.remove('show'), 700);
  }

  // ----- State -----
  let running=false, blind=false, sealed=false, shuffled=false, debugView=false;
  let gain=1.6, message="", lastT=performance.now();
  let plan = { x:0, y:0, r:28, trail:[] };
  let target = { x:0, y:0 };
  const tiles=[];

  // Precision gates
  let commitMode = 'exit';           // 'dwell' | 'exit' | 'press'
  let DWELL_MS = 800;                // adjustable
  let MIN_SPACE_FACTOR = 1.6;        // tile radii between commits
  const MIN_COMMIT_GAP = 520;        // ms between any commits
  const REPEAT_COOLDOWN = 900;       // ms before same tile can repeat
  let entered = null;                // {tile, tEnter, ready}
  let lastCommit = null;             // {label,x,y,t}
  let dwellTimer = 0;
  let readyVisual = 0;

  // Layout
  const baseLayout = {
    ring1:[...'ABCDEFGH'],
    ring2:[...'IJKLMNOP'],
    ring3:[...'QRSTUVWXYZ'],
    numbers:[...'1234567890'],
    corners:['YES','NO','GOODBYE']
  };
  let layout = JSON.parse(JSON.stringify(baseLayout));
  function shuffleArr(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }
  function refreshLayout(){
    layout = JSON.parse(JSON.stringify(baseLayout));
    if(shuffled){
      shuffleArr(layout.ring1); shuffleArr(layout.ring2); shuffleArr(layout.ring3); shuffleArr(layout.numbers);
    }
  }

  // ----- Sizing -----
  function sizeCanvas(){
    const rect = cv.getBoundingClientRect();
    cv.width = Math.max(10, rect.width * DPR);
    cv.height = Math.max(10, rect.height * DPR);
    plan.r = Math.max(22*DPR, Math.min(cv.width, cv.height)*0.05); // larger for touch
    centerPlanchette();
    draw();
  }
  window.addEventListener('resize', sizeCanvas);
  window.addEventListener('orientationchange', ()=>setTimeout(sizeCanvas, 250));
  requestAnimationFrame(sizeCanvas);

  function centerPlanchette(){
    plan.x = cv.width * 0.52;
    plan.y = cv.height * 0.60;
    target.x = plan.x; target.y = plan.y;
  }

  // ----- Drawing -----
  function drawBoard(){
    const W=cv.width, H=cv.height;
    ctx.clearRect(0,0,W,H);
    const g=ctx.createRadialGradient(W*0.62,H*0.35,10, W*0.62,H*0.35, Math.max(W,H)*0.9);
    g.addColorStop(0,'rgba(255,255,255,0.05)'); g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1;
    for(let y=0;y<H;y+=Math.max(24,DPR*26)){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke(); }
    for(let x=0;x<W;x+=Math.max(24,DPR*26)){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,H); ctx.stroke(); }

    tiles.length=0;
    const cx=W*0.52, cy=H*0.60, baseR=Math.min(W,H)*0.36;
    ctx.strokeStyle='rgba(200,210,230,0.08)'; ctx.lineWidth=Math.max(1, Math.min(W,H)*0.002);
    [0.70,0.86,1.02].forEach(m=>{ ctx.beginPath(); ctx.arc(cx,cy,baseR*m,0,Math.PI*2); ctx.stroke(); });

    const drawRing=(arr,r)=>{
      const n=arr.length, a0=-Math.PI*0.8, a1=-Math.PI*0.2;
      for(let i=0;i<n;i++){
        const t=i/(n-1); const ang=a0+(a1-a0)*t; const x=cx+Math.cos(ang)*r, y=cy+Math.sin(ang)*r;
        tiles.push({x,y,r:Math.min(W,H)*0.040,label:arr[i]});
        if(!blind || debugView){
          ctx.fillStyle='#cfd6e6';
          ctx.font=(Math.min(W,H)*0.05)+'px ui-monospace,Menlo,Consolas';
          ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(arr[i],x,y);
        } else {
          ctx.fillStyle='rgba(180,190,210,0.16)'; ctx.beginPath(); ctx.arc(x,y,Math.min(W,H)*0.009,0,Math.PI*2); ctx.fill();
        }
      }
    };

    drawRing(layout.ring1, baseR*0.70);
    drawRing(layout.ring2, baseR*0.86);
    drawRing(layout.ring3, baseR*1.02);

    // numbers
    const nbY=cy+baseR*0.55, nbR=Math.min(W,H)*0.040;
    for(let i=0;i<layout.numbers.length;i++){
      const x=(W*0.20)+i*(W*0.6/(layout.numbers.length-1));
      tiles.push({x,y:nbY,r:nbR,label:layout.numbers[i]});
      if(!blind || debugView){
        ctx.fillStyle='#aab3c7'; ctx.font=(Math.min(W,H)*0.045)+'px ui-monospace,Menlo'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(layout.numbers[i],x,nbY);
      } else {
        ctx.fillStyle='rgba(180,190,210,0.16)'; ctx.beginPath(); ctx.arc(x,nbY,Math.min(W,H)*0.009,0,Math.PI*2); ctx.fill();
      }
    }

    // corners
    const c=layout.corners;
    const corners=[{x:W*0.18,y:H*0.18,l:c[0],col:'#7bf59a'},{x:W*0.82,y:H*0.18,l:c[1],col:'#ffb3b3'},{x:W*0.50,y:H*0.18,l:c[2],col:'#9aa3b2'}];
    for(const k of corners){
      tiles.push({x:k.x,y:k.y,r:Math.min(W,H)*0.052,label:k.l});
      if(!blind || debugView){
        ctx.fillStyle=k.col; ctx.font=(Math.min(W,H)*0.04)+'px ui-monospace,Menlo'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(k.l,k.x,k.y);
      } else {
        ctx.strokeStyle='rgba(200,210,230,0.16)'; ctx.strokeRect(k.x-18,k.y-12,36,24);
      }
    }

    // ready ring
    if(entered && entered.tile){
      const t = entered.tile;
      ctx.strokeStyle='rgba(122,225,255,0.65)'; ctx.lineWidth=3;
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.r*1.15, -Math.PI/2, (-Math.PI/2) + readyVisual*2*Math.PI);
      ctx.stroke();
    }
  }

  function drawPlanchette(){
    const r=plan.r; const x=plan.x, y=plan.y;
    ctx.strokeStyle='rgba(122,225,255,0.22)'; ctx.lineWidth=2;
    ctx.beginPath(); for(let i=0;i<plan.trail.length;i++){ const p=plan.trail[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke();
    ctx.fillStyle='rgba(16,24,36,0.92)'; ctx.strokeStyle='rgba(45,90,150,0.85)'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.ellipse(x,y,r*1.1,r,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.beginPath(); ctx.arc(x,y,r*0.38,0,Math.PI*2); ctx.fill();
  }

  function draw(){ drawBoard(); drawPlanchette(); }

  // ----- Touch Input (canvas only) -----
  function touchPoint(e){
    const t = e.changedTouches[0];
    const rect = cv.getBoundingClientRect();
    return { x:(t.clientX-rect.left)*DPR, y:(t.clientY-rect.top)*DPR, t: e.timeStamp };
  }
  cv.addEventListener('touchstart', e=>{
    e.preventDefault();
    const p = touchPoint(e);
    target.x = clamp(p.x, 0, cv.width);
    target.y = clamp(p.y, 0, cv.height);
    if(commitMode==='press'){ handlePressStart(p); }
  }, {passive:false});

  cv.addEventListener('touchmove', e=>{
    e.preventDefault();
    const p = touchPoint(e);
    const tx = (target.x || p.x);
    const ty = (target.y || p.y);
    target.x = clamp(tx + (p.x - tx) * (0.36 * gain), 0, cv.width);
    target.y = clamp(ty + (p.y - ty) * (0.36 * gain), 0, cv.height);
  }, {passive:false});

  cv.addEventListener('touchend', e=>{
    e.preventDefault();
    const p = touchPoint(e);
    if(commitMode==='press'){ handlePressEnd(p); }
  }, {passive:false});

  // ----- Hit testing / entry tracking -----
  function hit(x,y){ for(const t of tiles){ if(Math.hypot(x-t.x,y-t.y)<=t.r) return t; } return null; }

  function onTileState(dt){
    const curr = hit(plan.x, plan.y);
    // entering new tile
    if(curr && (!entered || entered.tile!==curr)){
      entered = { tile: curr, tEnter: performance.now(), ready: false };
      readyVisual = 0;
      dwellTimer = 0;
    }
    // leaving tile
    if(!curr && entered && entered.tile && entered.ready && commitMode==='exit'){
      tryCommit(entered.tile, 'exit');
      entered = null; readyVisual=0;
    }
    if(!curr){ entered = null; readyVisual=0; dwellTimer=0; return; }

    dwellTimer += dt;
    readyVisual = Math.min(1, dwellTimer / DWELL_MS);
    badgeReady.style.display = (readyVisual>=1? 'inline-block':'none');
    if(readyVisual>=1) entered.ready = true;

    if(commitMode==='dwell' && entered.ready){
      tryCommit(curr, 'dwell');
      entered.ready = false; dwellTimer = 0;
    }
  }

  // ----- Commit gating -----
  function canCommitCommon(tile, now){
    if(lastCommit){
      const dist = Math.hypot(tile.x - lastCommit.x, tile.y - lastCommit.y);
      if(dist < tile.r * MIN_SPACE_FACTOR) return {ok:false, reason:'spacing'};
      if(now - lastCommit.t < MIN_COMMIT_GAP) return {ok:false, reason:'gap'};
      if(lastCommit.label===tile.label && (now - lastCommit.t) < REPEAT_COOLDOWN) return {ok:false, reason:'repeat'};
    }
    return {ok:true};
  }

  function tryCommit(tile, mode){
    if(!running) return;
    const now = Date.now();
    const gate = canCommitCommon(tile, now);
    if(!gate.ok) return;
    commit(tile, now);
  }

  function commit(tile, now){
    const lab = tile.label;
    if(lab==='YES' || lab==='NO'){ message += ` [${lab}]`; toast(lab); }
    else if(lab==='GOODBYE'){ message += ' [GOODBYE]'; toast('GOODBYE'); stop(); }
    else if(lab.length===1){ message += lab; toast(lab); }
    lastCommit = {label: lab, x: tile.x, y: tile.y, t: now};
    updateLog();
  }

  function updateLog(){
    if((sealed || blind) && running && !debugView){ logEl.textContent = '(sealed)'; }
    else { logEl.textContent = message || '(no text)'; }
    statusEl.textContent = (running?'Listening':'Idle') + ' • ' + (message.replace(/\s/g,'').length) + ' chars';
  }

  // ----- Press mode (double-tap within tile to commit) -----
  let pressCandidate = null; // {tile, tDown}
  const DOUBLE_TAP_MS = 380;
  function handlePressStart(p){
    const t = hit(plan.x, plan.y);
    if(!t) { pressCandidate = null; return; }
    if(pressCandidate && pressCandidate.tile===t && (p.t - pressCandidate.tDown) < DOUBLE_TAP_MS){
      tryCommit(t, 'press'); pressCandidate = null;
    } else {
      pressCandidate = {tile:t, tDown:p.t};
    }
  }
  function handlePressEnd(p){ /* no-op */ }

  // ----- Loop -----
  function tick(){
    const t = performance.now();
    const dt = (t - lastT) || 16; lastT = t;
    const nx = (target.x || plan.x);
    const ny = (target.y || plan.y);
    const wob1 = Math.sin((t+97)*0.006)*3.5;
    const wob2 = Math.cos((t+31)*0.004)*3.5;
    plan.x = clamp(plan.x + (nx + wob1 - plan.x) * 0.18, 0, cv.width);
    plan.y = clamp(plan.y + (ny + wob2 - plan.y) * 0.18, 0, cv.height);
    if(running){
      plan.trail.push({x:plan.x,y:plan.y}); if(plan.trail.length>900) plan.trail.shift();
      onTileState(dt);
    }
    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ----- Controls -----
  function start(){ if(running) return; running=true; message=""; plan.trail.length=0; lastCommit=null; entered=null; dwellTimer=0; readyVisual=0; updateLog(); }
  function stop(){ if(!running) return; running=false; if((blind||sealed) && !debugView){ logEl.textContent = message || '(no text)'; } updateLog(); }
  function reset(){ running=false; message=""; plan.trail.length=0; dwellTimer=0; lastCommit=null; entered=null; readyVisual=0; centerPlanchette(); draw(); updateLog(); }
  function exportJSON(){
    const body = {
      ts: Date.now(), blind, sealed, shuffled, gain, commitMode, DWELL_MS, MIN_SPACE_FACTOR, message,
      trail: plan.trail.slice(-400),
      tiles: tiles.map(t=>({x:t.x,y:t.y,r:t.r,label:t.label}))
    };
    const blob = new Blob([JSON.stringify(body,null,2)], {type:'application/json'});
    const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='spirit_board_mobile_precision_v2.json'; a.click();
  }

  // Bind buttons/inputs
  $('#btnStart').onclick = start;
  $('#btnStop').onclick = stop;
  $('#btnReset').onclick = reset;
  $('#btnCenter').onclick = ()=>{ centerPlanchette(); draw(); };
  $('#btnExport').onclick = exportJSON;
  $('#chkBlind').onchange = (e)=>{ blind = e.target.checked; updateLog(); draw(); };
  $('#chkSeal').onchange = (e)=>{ sealed = e.target.checked; updateLog(); };
  $('#chkShuffle').onchange = (e)=>{ shuffled = e.target.checked; refreshLayout(); draw(); };
  $('#chkDebug').onchange = (e)=>{ debugView = e.target.checked; updateLog(); draw(); };
  $('#rngGain').oninput = (e)=>{ gain = parseFloat(e.target.value||'1.6'); };
  $('#selMode').onchange = (e)=>{ commitMode = e.target.value; };
  $('#rngDwell').oninput = (e)=>{ DWELL_MS = parseInt(e.target.value||'800',10); };
  $('#rngSpace').oninput = (e)=>{ MIN_SPACE_FACTOR = parseFloat(e.target.value||'1.6'); };

  // Boot
  refreshLayout();
  centerPlanchette(); draw(); updateLog();
})();</script>
</body>
</html>
