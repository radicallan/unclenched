
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Spirit Board — OMNI v2 (Desktop + Mobile)</title>
<style>
  :root{--bg:#0b0d12;--panel:#0f121a;--ink:#e7ebf2;--muted:#96a0b1;--accent:#7ae1ff;--good:#7bf59a;--warn:#ffd166;--bad:#ff6b6b}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:flex;flex-direction:column;min-height:100vh}
  header{display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:10px;background:var(--panel);border-bottom:1px solid #1b2330;position:sticky;top:0;z-index:10}
  header .sp{flex:1}
  button{appearance:none;border:1px solid #2a3a58;background:#0f1726;color:var(--ink);padding:9px 12px;border-radius:12px;cursor:pointer}
  button:active{transform:scale(0.98)}
  label{display:inline-flex;align-items:center;gap:6px}
  select,input[type="range"]{accent-color:#2de2ff;background:#0f1726;color:var(--ink);border:1px solid #2a3a58;border-radius:10px;padding:6px 8px}
  #stage{position:relative;flex:1;min-height:56vh}
  #cv{position:absolute;inset:0;display:block;width:100%;height:100%;touch-action:none;-webkit-user-select:none;user-select:none}
  #log{min-height:120px;max-height:38vh;overflow:auto;padding:10px;background:#0a0f16;border-top:1px solid #1b2330;font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .small{font-size:13px;color:#97a1b1}
  .pill{padding:4px 10px;border-radius:999px;border:1px solid #2a3a58;background:#0f1726}
  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#101826;border:1px solid #29405f;color:#eaf4ff;padding:8px 12px;border-radius:10px;opacity:0;transition:opacity .2s}
  .toast.show{opacity:1}
  details{background:#0d121b;border:1px solid #1b2330;border-radius:12px;padding:8px}
  summary{cursor:pointer;color:#b6c2d6}
  .hud{position:fixed;right:10px;top:10px;display:flex;gap:8px;z-index:20}
  .badge{background:#0f1726;border:1px solid #2a3a58;color:#cfe2ff;padding:4px 8px;border-radius:999px;font-size:12px}
  .badge.green{border-color:#2f6; color:#cfffdf}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="row" style="width:100%">
      <button id="btnStart" type="button">Invite</button>
      <button id="btnStop" type="button">Goodbye</button>
      <button id="btnReset" type="button">Reset</button>
      <button id="btnCenter" type="button">Center</button>
      <div class="sp"></div>
      <span id="status">Idle • 0 chars</span>
    </div>
    <details open>
      <summary>Controls</summary>
      <div class="row" style="margin-top:8px">
        <label><input type="checkbox" id="chkBlind"> Blind</label>
        <label><input type="checkbox" id="chkSeal"> Seal</label>
        <label><input type="checkbox" id="chkShuffle"> Shuffle</label>
        <label><input type="checkbox" id="chkDebug"> Debug view</label>
        <label><input type="checkbox" id="chkSound" checked> Audio tick</label>
        <label><input type="checkbox" id="chkHiSens"> High-sensitivity (desktop)</label>
        <label><input type="checkbox" id="chkNeedReady" checked> Require READY to commit</label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>Gain <input type="range" id="rngGain" min="0.6" max="2.6" step="0.1" value="1.8"></label>
        <label>Commit
          <select id="selMode">
            <option value="exit" selected>Exit (very safe)</option>
            <option value="dwell">Dwell (safe)</option>
            <option value="press">Press (double‑tap/‑click)</option>
          </select>
        </label>
        <label>Dwell <input type="range" id="rngDwell" min="400" max="1600" step="50" value="900"></label>
        <label>Spacing <input type="range" id="rngSpace" min="1.0" max="2.2" step="0.1" value="1.7"></label>
        <label>Commit gap <input type="range" id="rngGap" min="300" max="1200" step="50" value="600"></label>
        <label>Repeat cooldown <input type="range" id="rngRepeat" min="400" max="1600" step="50" value="950"></label>
        <label>Arm delay <input type="range" id="rngArm" min="100" max="800" step="50" value="250"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>Assist
          <select id="selAssist">
            <option value="off" selected>Off</option>
            <option value="bigram">Bigram Bias</option>
            <option value="lexicon">Lexicon Snap</option>
          </select>
        </label>
        <label>Warm‑up (s) <input type="range" id="rngWarm" min="0" max="40" step="5" value="12"></label>
      </div>
    </details>
    <div class="small">Exit mode: enter a letter → ring fills → <b>slide off</b> to commit. “Require READY” forces the ring to complete before any commit (even Press).</div>
  </header>

  <div id="stage"><canvas id="cv"></canvas></div>
  <div id="log">(nothing yet)</div>
  <div id="toast" class="toast">Committed</div>

  <div class="hud">
    <div id="badgeMode" class="badge">Mode: Exit</div>
    <div id="badgeReady" class="badge">Ready: 0%</div>
  </div>
</div>

<script>
(function(){
  const $=s=>document.querySelector(s);
  const DPR=Math.min(2, window.devicePixelRatio||1);
  const cv=$('#cv'), ctx=cv.getContext('2d',{alpha:true});
  const statusEl=$('#status'), logEl=$('#log'), toastEl=$('#toast');
  const badgeMode=$('#badgeMode'), badgeReady=$('#badgeReady');
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  let audioOn=true, ac=null;
  function beep(freq=660, dur=0.05){
    if(!audioOn) return;
    try{ if(!ac) ac=new (window.AudioContext||window.webkitAudioContext)();
      const o=ac.createOscillator(), g=ac.createGain();
      o.type='sine'; o.frequency.value=freq;
      g.gain.setValueAtTime(0.0001, ac.currentTime);
      g.gain.exponentialRampToValueAtTime(0.05, ac.currentTime+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+dur);
      o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+dur);
    }catch(e){} }
  function toast(msg){ toastEl.textContent=msg; toastEl.classList.add('show'); clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.classList.remove('show'),700); }
  function isTouch(){ return 'ontouchstart' in window || navigator.maxTouchPoints>0; }

  // State
  let running=false, blind=false, sealed=false, shuffled=false, debugView=false, pointerLocked=false, hiSens=false, needReady=true;
  let gain=1.8, message="", lastT=performance.now();
  let plan={x:0,y:0,r:28,trail:[]}, target={x:0,y:0}; const tiles=[];

  // Commit control
  let commitMode='exit'; let DWELL_MS=900, MIN_SPACE_FACTOR=1.7, MIN_COMMIT_GAP=600, REPEAT_COOLDOWN=950, ARM_DELAY=250;
  let entered=null, lastCommit=null, dwellTimer=0, readyVisual=0, armed=false;

  // Assist + warmup
  let assistMode='off', warmupSec=12, startTs=0;
  const BIGRAM=(()=>{ const list=['TH','HE','IN','ER','AN','RE','ED','ON','ES','ST','EN','AT','TO','NT','HA','ND','OU','EA','NG','AS','OR','TI','IS','ET','IT','AR','TE','SE','HI','OF']; const map={}; list.forEach((b,i)=>map[b]=(list.length-i)); return map; })();
  const SMALL_LEXICON=new Set(['YES','NO','HELLO','GOODBYE','PLEASE','THANK','YOU','WHO','WHAT','WHEN','WHERE','WHY','HOW','LOVE','PEACE','LIGHT','TRUTH','SAFE','HELP','ALLAN','ELI']);

  // Sizing
  function sizeCanvas(){ const r=cv.getBoundingClientRect(); cv.width=Math.max(10,r.width*DPR); cv.height=Math.max(10,r.height*DPR); plan.r=Math.max(isTouch()?22:20, Math.min(cv.width,cv.height)*(isTouch()?0.05:0.04)); center(); draw(); }
  function center(){ plan.x=cv.width*0.52; plan.y=cv.height*0.60; target.x=plan.x; target.y=plan.y; }
  window.addEventListener('resize', sizeCanvas); window.addEventListener('orientationchange', ()=>setTimeout(sizeCanvas,250)); requestAnimationFrame(sizeCanvas);

  // Layout
  const baseLayout={ring1:[...'ABCDEFGH'], ring2:[...'IJKLMNOP'], ring3:[...'QRSTUVWXYZ'], numbers:[...'1234567890'], corners:['YES','NO','GOODBYE']};
  let layout=JSON.parse(JSON.stringify(baseLayout));
  function shuffleArr(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }
  function refreshLayout(){ layout=JSON.parse(JSON.stringify(baseLayout)); if(shuffled){ shuffleArr(layout.ring1); shuffleArr(layout.ring2); shuffleArr(layout.ring3); shuffleArr(layout.numbers);} }

  // Draw
  function drawBoard(){
    const W=cv.width,H=cv.height,cx=W*0.52,cy=H*0.60,baseR=Math.min(W,H)*0.36;
    ctx.clearRect(0,0,W,H);
    const g=ctx.createRadialGradient(W*0.62,H*0.35,10, W*0.62,H*0.35, Math.max(W,H)*0.9);
    g.addColorStop(0,'rgba(255,255,255,0.05)'); g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1;
    for(let y=0;y<H;y+=Math.max(24,DPR*26)){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke(); }
    for(let x=0;x<W;x+=Math.max(24,DPR*26)){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,H); ctx.stroke(); }

    tiles.length=0;
    ctx.strokeStyle='rgba(200,210,230,0.08)'; ctx.lineWidth=Math.max(1, Math.min(W,H)*0.002);
    [0.70,0.86,1.02].forEach(m=>{ ctx.beginPath(); ctx.arc(cx,cy,baseR*m,0,Math.PI*2); ctx.stroke(); });

    const drawRing=(arr,r)=>{
      const n=arr.length, a0=-Math.PI*0.8, a1=-Math.PI*0.2;
      for(let i=0;i<n;i++){
        const t=i/(n-1), ang=a0+(a1-a0)*t, x=cx+Math.cos(ang)*r, y=cy+Math.sin(ang)*r;
        tiles.push({x,y,r:Math.min(W,H)*(isTouch()?0.040:0.032), label:arr[i]});
        if(!blind || debugView){ ctx.fillStyle='#cfd6e6'; ctx.font=(Math.min(W,H)*(isTouch()?0.05:0.035))+'px ui-monospace,Menlo,Consolas'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(arr[i],x,y); }
        else { ctx.fillStyle='rgba(180,190,210,0.14)'; ctx.beginPath(); ctx.arc(x,y,Math.min(W,H)*0.008,0,Math.PI*2); ctx.fill(); }
      }
    };
    drawRing(layout.ring1, baseR*0.70); drawRing(layout.ring2, baseR*0.86); drawRing(layout.ring3, baseR*1.02);

    // numbers
    const nbY=cy+baseR*0.55, nbR=Math.min(W,H)*(isTouch()?0.040:0.032);
    for(let i=0;i<layout.numbers.length;i++){
      const x=(W*0.20)+i*(W*0.6/(layout.numbers.length-1));
      tiles.push({x,y:nbY,r:nbR,label:layout.numbers[i]});
      if(!blind || debugView){ ctx.fillStyle='#aab3c7'; ctx.font=(Math.min(W,H)*(isTouch()?0.045:0.03))+'px ui-monospace,Menlo'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(layout.numbers[i],x,nbY); }
      else { ctx.fillStyle='rgba(180,190,210,0.14)'; ctx.beginPath(); ctx.arc(x,nbY,Math.min(W,H)*0.008,0,Math.PI*2); ctx.fill(); }
    }

    // corners
    const c=layout.corners;
    const corners=[{x:W*0.18,y:H*0.18,l:c[0],col:'#7bf59a'},{x:W*0.82,y:H*0.18,l:c[1],col:'#ffb3b3'},{x:W*0.50,y:H*0.18,l:c[2],col:'#9aa3b2'}];
    for(const k of corners){
      tiles.push({x:k.x,y:k.y,r:Math.min(W,H)*(isTouch()?0.052:0.042),label:k.l});
      if(!blind || debugView){ ctx.fillStyle=k.col; ctx.font=(Math.min(W,H)*(isTouch()?0.04:0.028))+'px ui-monospace,Menlo'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(k.l,k.x,k.y); }
      else { ctx.strokeStyle='rgba(200,210,230,0.14)'; ctx.strokeRect(k.x-18,k.y-12,36,24); }
    }

    // Ready ring (thicker + green when done)
    if(entered && entered.tile){
      const t=entered.tile;
      ctx.lineWidth=5;
      ctx.strokeStyle = (readyVisual>=1 ? 'rgba(123,245,154,0.9)' : 'rgba(122,225,255,0.7)');
      ctx.beginPath(); ctx.arc(t.x, t.y, t.r*1.18, -Math.PI/2, (-Math.PI/2)+readyVisual*2*Math.PI); ctx.stroke();
    }
  }
  function drawPlanchette(){
    const r=plan.r,x=plan.x,y=plan.y;
    ctx.strokeStyle='rgba(122,225,255,0.22)'; ctx.lineWidth=2; ctx.beginPath();
    for(let i=0;i<plan.trail.length;i++){ const p=plan.trail[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke();
    ctx.fillStyle='rgba(16,24,36,0.92)'; ctx.strokeStyle='rgba(45,90,150,0.85)'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.ellipse(x,y,r*1.1,r,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.beginPath(); ctx.arc(x,y,r*0.38,0,Math.PI*2); ctx.fill();
  }
  function draw(){ drawBoard(); drawPlanchette(); }

  // Input
  function tPoint(e){ const t=e.changedTouches[0], r=cv.getBoundingClientRect(); return {x:(t.clientX-r.left)*DPR, y:(t.clientY-r.top)*DPR, time:e.timeStamp}; }
  cv.addEventListener('touchstart', e=>{ e.preventDefault(); const p=tPoint(e); target.x=clamp(p.x,0,cv.width); target.y=clamp(p.y,0,cv.height); if(commitMode==='press') pressStart(p); }, {passive:false});
  cv.addEventListener('touchmove', e=>{ e.preventDefault(); const p=tPoint(e); const tx=(target.x||p.x), ty=(target.y||p.y); target.x=clamp(tx+(p.x-tx)*(0.36*gain),0,cv.width); target.y=clamp(ty+(p.y-ty)*(0.36*gain),0,cv.height); }, {passive:false});
  cv.addEventListener('touchend', e=>{ e.preventDefault(); const p=tPoint(e); if(commitMode==='press') pressEnd(p); }, {passive:false});

  cv.addEventListener('pointermove', e=>{
    if(isTouch() || pointerLocked) return;
    const r=cv.getBoundingClientRect(); const px=(e.clientX-r.left)*DPR, py=(e.clientY-r.top)*DPR;
    const tx=(target.x||px), ty=(target.y||py); target.x=clamp(tx+(px-tx)*(0.35*gain),0,cv.width); target.y=clamp(ty+(py-ty)*(0.35*gain),0,cv.height);
  });
  cv.addEventListener('pointerdown', e=>{ if(!isTouch()) cv.setPointerCapture(e.pointerId); if(commitMode==='press') clickStart(e); });
  cv.addEventListener('pointerup', e=>{ if(commitMode==='press') clickEnd(e); });

  function enablePointerLock(){ if(pointerLocked||!cv.requestPointerLock) return; cv.requestPointerLock(); }
  document.addEventListener('pointerlockchange', ()=>{ pointerLocked=(document.pointerLockElement===cv); });
  document.addEventListener('mousemove', e=>{
    if(!pointerLocked) return;
    const dx=(e.movementX||0)*DPR*gain, dy=(e.movementY||0)*DPR*gain;
    target.x=clamp((target.x||plan.x)+dx,0,cv.width); target.y=clamp((target.y||plan.y)+dy,0,cv.height);
  });

  // Hit & assist
  function hit(x,y){ for(const t of tiles){ if(Math.hypot(x-t.x,y-t.y)<=t.r) return t; } return null; }
  function nearby(x,y,rf=1.5){ const R=Math.min(cv.width,cv.height)*0.065*rf, out=[]; for(const t of tiles){ const d=Math.hypot(x-t.x,y-t.y); if(d<=R) out.push({tile:t,d}); } out.sort((a,b)=>a.d-b.d); return out; }
  function bigramScore(prev,next){ if(!prev||!next) return 0; const key=(prev+next).toUpperCase(); return BIGRAM[key]||0; }
  function chooseAssist(primary){
    if(assistMode==='off') return primary;
    const prev=lastCommit && lastCommit.label && lastCommit.label.length===1 ? lastCommit.label : null;
    const nb=nearby(plan.x,plan.y,1.6); if(nb.length===0) return primary;
    let best={score:-1e9, tile:primary};
    for(const {tile,d} of nb){
      let score=-d;
      if(assistMode==='bigram' && prev) score += bigramScore(prev,tile.label)*4.0;
      if(assistMode==='lexicon'){
        const maybe=(message+(tile.label.length===1?tile.label:'')).toUpperCase();
        for(const w of SMALL_LEXICON){ if(w.startsWith(maybe)) score += 6.0; }
        const isV='AEIOUY'.includes(tile.label), prevIsV=prev?'AEIOUY'.includes(prev):null;
        if(prev && prevIsV!==null && isV!==prevIsV) score += 1.5;
      }
      if(lastCommit && lastCommit.label===tile.label) score -= 3.2;
      if(score>best.score) best={score,tile};
    }
    const maxJump=Math.min(cv.width,cv.height)*0.12;
    if(Math.hypot(best.tile.x-primary.x, best.tile.y-primary.y)>maxJump) return primary;
    return best.tile;
  }

  // Commit gating
  function canCommit(tile, now){
    if(needReady && !(entered && entered.ready)) return false;
    if(lastCommit){
      const dist=Math.hypot(tile.x-lastCommit.x, tile.y-lastCommit.y);
      if(dist < tile.r*MIN_SPACE_FACTOR) return false;
      if(now - lastCommit.t < MIN_COMMIT_GAP) return false;
      if(lastCommit.label===tile.label && (now-lastCommit.t)<REPEAT_COOLDOWN) return false;
    }
    return true;
  }

  function doCommit(tile, now){
    const lab=tile.label;
    if(lab==='YES' || lab==='NO'){ message += ` [${lab}]`; toast(lab); beep(520,0.05); }
    else if(lab==='GOODBYE'){ message += ' [GOODBYE]'; toast('GOODBYE'); beep(420,0.08); stop(); }
    else if(lab.length===1){ message += lab; toast(lab); beep(660,0.03); }
    lastCommit={label:lab, x:tile.x, y:tile.y, t:now};
    updateLog();
    // disarm until we re-enter & arm again
    armed=false; entered && (entered.ready=false);
  }

  // Entry tracking
  function onTileState(dt){
    let tile = hit(plan.x, plan.y);
    if(tile && assistMode!=='off') tile = chooseAssist(tile);
    // warmup
    if(running && warmupSec>0 && (Date.now()-startTs) < warmupSec*1000){
      if(!(tile && (tile.label==='YES' || tile.label==='NO'))) tile=null;
    }
    // entering
    if(tile && (!entered || entered.tile!==tile)){
      entered={tile, tEnter:performance.now(), ready:false};
      readyVisual=0; dwellTimer=0; armed=false;
    }
    // leaving
    if(!tile){
      if(entered && entered.tile && entered.ready && commitMode==='exit' && armed){
        const now=Date.now(); if(canCommit(entered.tile, now)) doCommit(entered.tile, now);
      }
      entered=null; readyVisual=0; dwellTimer=0; armed=false; return;
    }
    // within tile
    dwellTimer += dt;
    const sinceEnter = performance.now() - (entered ? entered.tEnter : performance.now());
    armed = sinceEnter >= ARM_DELAY; // short arming delay
    readyVisual = Math.min(1, dwellTimer / DWELL_MS);
    entered.ready = readyVisual >= 1;
    badgeReady.textContent = 'Ready: ' + Math.round(readyVisual*100) + '%';
    badgeReady.classList.toggle('green', entered.ready);

    if(commitMode==='dwell' && entered.ready && armed){
      const now=Date.now(); if(canCommit(tile, now)) doCommit(tile, now);
      entered.ready=false; dwellTimer=0; armed=false; // require re-entry
    }
  }

  // Press mode (double tap/click) — now also requires READY if needReady=true
  let pressCand=null; const DBL_MS=380;
  function pressStart(p){
    const t=hit(plan.x, plan.y); if(!t){ pressCand=null; return; }
    if(pressCand && pressCand.tile===t && (p.time - pressCand.tDown) < DBL_MS){
      const now=Date.now(); if(canCommit(t, now)) doCommit(t, now); pressCand=null; return;
    }
    pressCand={tile:t, tDown:p.time};
  }
  function pressEnd(p){ /* no-op */ }
  function clickStart(e){
    const r=cv.getBoundingClientRect(); const px=(e.clientX-r.left)*DPR, py=(e.clientY-r.top)*DPR;
    target.x=px; target.y=py;
    const t=hit(px,py); const time=performance.now();
    pressStart({time, tile:t});
  }
  function clickEnd(e){}

  // Loop
  function tick(){
    const t=performance.now(), dt=(t-lastT)||16; lastT=t;
    const wob1=Math.sin((t+97)*0.006)*(isTouch()?3.5:6), wob2=Math.cos((t+31)*0.004)*(isTouch()?3.5:6);
    const nx=(target.x||plan.x), ny=(target.y||plan.y);
    plan.x=clamp(plan.x + (nx + wob1 - plan.x)*0.18, 0, cv.width);
    plan.y=clamp(plan.y + (ny + wob2 - plan.y)*0.18, 0, cv.height);
    if(running){
      plan.trail.push({x:plan.x,y:plan.y}); if(plan.trail.length>(isTouch()?900:1200)) plan.trail.shift();
      onTileState(dt);
    }
    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Log & status
  function updateLog(){ if((sealed||blind) && running && !debugView) logEl.textContent='(sealed)'; else logEl.textContent=message||'(no text)'; statusEl.textContent=(running?'Listening':'Idle') + ' • ' + (message.replace(/\s/g,'').length) + ' chars'; }

  // Controls
  function start(){ if(running) return; running=true; message=''; plan.trail.length=0; lastCommit=null; entered=null; dwellTimer=0; readyVisual=0; startTs=Date.now(); updateLog(); if(hiSens && !isTouch()) enablePointerLock(); }
  function stop(){ if(!running) return; running=false; if(pointerLocked && document.exitPointerLock) document.exitPointerLock(); updateLog(); }
  function reset(){ running=false; message=''; plan.trail.length=0; dwellTimer=0; lastCommit=null; entered=null; readyVisual=0; armed=false; center(); draw(); updateLog(); }

  function exportJSON(){ const body={ ts:Date.now(), blind, sealed, shuffled, debugView, audioOn, hiSens, needReady, gain, commitMode, DWELL_MS, MIN_SPACE_FACTOR, MIN_COMMIT_GAP, REPEAT_COOLDOWN, ARM_DELAY, assistMode, warmupSec, message, trail:plan.trail.slice(-500), tiles:tiles.map(t=>({x:t.x,y:t.y,r:t.r,label:t.label})) }; const blob=new Blob([JSON.stringify(body,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='spirit_board_omni_v2_session.json'; a.click(); }

  $('#btnStart').onclick=start; $('#btnStop').onclick=stop; $('#btnReset').onclick=reset; $('#btnCenter').onclick=()=>{center(); draw();};
  $('#selMode').onchange=e=>{ commitMode=e.target.value; badgeMode.textContent='Mode: '+(commitMode[0].toUpperCase()+commitMode.slice(1)); };
  $('#rngDwell').oninput=e=>{ DWELL_MS=parseInt(e.target.value,10)||900; };
  $('#rngSpace').oninput=e=>{ MIN_SPACE_FACTOR=parseFloat(e.target.value)||1.7; };
  $('#rngGap').oninput=e=>{ MIN_COMMIT_GAP=parseInt(e.target.value,10)||600; };
  $('#rngRepeat').oninput=e=>{ REPEAT_COOLDOWN=parseInt(e.target.value,10)||950; };
  $('#rngArm').oninput=e=>{ ARM_DELAY=parseInt(e.target.value,10)||250; };
  $('#rngGain').oninput=e=>{ gain=parseFloat(e.target.value)||1.8; };
  $('#selAssist').onchange=e=>{ assistMode=e.target.value; };
  $('#rngWarm').oninput=e=>{ warmupSec=parseInt(e.target.value,10)||0; };
  $('#chkBlind').onchange=e=>{ blind=e.target.checked; updateLog(); draw(); };
  $('#chkSeal').onchange=e=>{ sealed=e.target.checked; updateLog(); };
  $('#chkShuffle').onchange=e=>{ shuffled=e.target.checked; refreshLayout(); draw(); };
  $('#chkDebug').onchange=e=>{ debugView=e.target.checked; updateLog(); draw(); };
  $('#chkSound').onchange=e=>{ audioOn=e.target.checked; };
  $('#chkHiSens').onchange=e=>{ hiSens=e.target.checked; if(!hiSens && pointerLocked && document.exitPointerLock) document.exitPointerLock(); };
  $('#chkNeedReady').onchange=e=>{ needReady=e.target.checked; };
  $('#btnExport').onclick=exportJSON;

  // Boot
  refreshLayout(); center(); draw(); updateLog();
})();</script>
</body>
</html>
