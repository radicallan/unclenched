<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Isometric Room — From‑Scratch Minimal (Works Everywhere)</title>
  <style>
    :root{ --bg:#0d1117; --ink:#e6edf3; --muted:#9da7b3; --line:#1f2632; --floor:#1d2540; --edge:#2a3654; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    header{padding:10px 14px;border-bottom:1px solid var(--line)}
    header b{letter-spacing:.3px}
    .wrap{padding:12px}
    .stage{border:1px solid var(--line);border-radius:12px;overflow:hidden;background:#0f1422}
    canvas{display:block;width:100%;height:520px;image-rendering:pixelated}
    .bar{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:8px;color:var(--muted);font-size:12px}
    .btn{background:#121a2b;border:1px solid var(--line);color:var(--ink);padding:6px 10px;border-radius:8px;cursor:pointer}
    .pill{padding:4px 8px;border:1px solid var(--line);border-radius:999px}
  </style>
</head>
<body>
  <header><b>Isometric Room</b> — ultra‑simple build to guarantee a visible room</header>
  <div class="wrap">
    <div class="stage"><canvas id="room" width="960" height="520"></canvas></div>
    <div class="bar">
      <div id="info" class="pill">—</div>
      <div>
        <button class="btn" id="fit">Fit</button>
        <button class="btn" id="zoomOut">−</button>
        <button class="btn" id="zoomIn">+</button>
      </div>
    </div>
  </div>

  <script>
    // ====== Clean slate: no DPR tricks, no transforms, just draw ======
    const canvas=document.getElementById('room');
    const ctx=canvas.getContext('2d');
    ctx.imageSmoothingEnabled=false;

    // Grid + tile geometry
    const GRID_W=14, GRID_H=10;      // smaller so it always fits
    const TILE_W=64, TILE_H=32;      // isometric diamond base
    let zoom=1.0;                    // simple zoom scalar

    // Basic palette
    const FLOOR_COLS=['#1d2540','#212a4a'];

    // Compute world dimensions in screen px (at zoom=1)
    function worldSize(){
      const w = (GRID_W + GRID_H) * (TILE_W/2);
      const h = (GRID_W + GRID_H) * (TILE_H/2);
      return {w,h};
    }

    // Place world so the whole grid is centered and visible
    let originX=0, originY=0; // top-left of the diamond bounds
    function fit(){
      const rect=canvas.getBoundingClientRect(); // CSS size
      const {w,h}=worldSize();
      // leave soft padding
      const pad=24;
      const availW=rect.width - pad*2;
      const availH=rect.height - pad*2;
      // calc zoom to fit both dimensions
      zoom=Math.min(availW/w, availH/h);
      // recompute origin so world is centered
      originX = (rect.width  - w*zoom)/2;
      originY = (rect.height - h*zoom)/2 + 24; // nudge down for headroom
      draw();
    }

    // Iso <-> Screen (z ignored)
    function isoToScreen(ix,iy){
      const x=(ix - iy) * (TILE_W/2) * zoom + originX + (GRID_H*(TILE_W/2))*zoom; // shift to keep everything positive
      const y=(ix + iy) * (TILE_H/2) * zoom + originY;
      return {x,y};
    }

    // Draw a single diamond tile
    function tile(x,y,fill){
      const p=isoToScreen(x,y);
      const hw=(TILE_W/2)*zoom, hh=(TILE_H/2)*zoom;
      ctx.fillStyle=fill; ctx.strokeStyle='#2b375a';
      ctx.beginPath();
      ctx.moveTo(p.x,       p.y);
      ctx.lineTo(p.x+hw,    p.y+hh);
      ctx.lineTo(p.x,       p.y+2*hh);
      ctx.lineTo(p.x-hw,    p.y+hh);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
    }

    // Simple checkerboard floor so you can SEE it immediately
    function drawFloor(){
      for(let y=0;y<GRID_H;y++){
        for(let x=0;x<GRID_W;x++){
          const c = FLOOR_COLS[(x+y)%2];
          tile(x,y,c);
        }
      }
    }

    // A tiny avatar block so it feels alive
    const avatar={x:Math.floor(GRID_W/2), y:Math.floor(GRID_H/2)};
    function drawAvatar(){
      const p=isoToScreen(avatar.x, avatar.y);
      const hh=(TILE_H/2)*zoom;
      ctx.fillStyle='#5a79e6';
      ctx.fillRect(p.x-6*zoom, p.y+hh-14*zoom, 12*zoom, 12*zoom);
      ctx.fillStyle='#f0d9c2';
      ctx.fillRect(p.x-5*zoom, p.y+hh-22*zoom, 10*zoom, 8*zoom);
    }

    // Full draw
    function draw(){
      // clear
      ctx.fillStyle='#0f1422';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      drawFloor();
      drawAvatar();
      // debug info
      const info=`Canvas ${canvas.width}×${canvas.height} | Zoom ${(zoom*100).toFixed(0)}% | Grid ${GRID_W}×${GRID_H}`;
      document.getElementById('info').textContent=info;
    }

    // Resize canvas pixels to its CSS size so it never looks blank
    function resizeCanvasToCSS(){
      const rect=canvas.getBoundingClientRect();
      // Make the drawing buffer match CSS size exactly (no DPR scaling to keep it bulletproof)
      const w=Math.max(300, Math.floor(rect.width));
      const h=Math.max(260, Math.floor(rect.height));
      if(canvas.width!==w || canvas.height!==h){ canvas.width=w; canvas.height=h; }
    }

    // Controls
    document.getElementById('zoomIn').onclick=()=>{ zoom=Math.min(2.5, zoom+0.1); draw(); };
    document.getElementById('zoomOut').onclick=()=>{ zoom=Math.max(0.4, zoom-0.1); draw(); };
    document.getElementById('fit').onclick=()=>{ fit(); };

    canvas.addEventListener('click',(e)=>{
      const rect=canvas.getBoundingClientRect();
      const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      // super simple: move avatar toward click by one step
      if(mx>canvas.width/2) avatar.x=Math.min(GRID_W-1, avatar.x+1); else avatar.x=Math.max(0, avatar.x-1);
      if(my>canvas.height/2) avatar.y=Math.min(GRID_H-1, avatar.y+1); else avatar.y=Math.max(0, avatar.y-1);
      draw();
    });

    // Init
    function init(){
      resizeCanvasToCSS();
      fit();
      draw();
    }
    window.addEventListener('resize',()=>{ resizeCanvasToCSS(); fit(); });
    init();
  </script>
</body>
</html>
