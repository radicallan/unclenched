<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixel Hotel Engine</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            background-color: #1a1a1a;
            margin: 0;
            overflow: hidden;
            font-family: 'VT323', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background: #2b2b2b;
            border: 4px solid #fff;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            image-rendering: pixelated; 
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        #chat-input {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            color: #fff;
            font-family: 'VT323', monospace;
            font-size: 24px;
            padding: 10px;
            outline: none;
        }

        #chat-btn {
            background: #e67e22;
            border: 2px solid #fff;
            color: white;
            font-family: 'VT323', monospace;
            font-size: 24px;
            padding: 0 20px;
            cursor: pointer;
            transition: transform 0.1s;
        }

        #chat-btn:active { transform: scale(0.95); }

        .logo {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255,255,255,0.3);
            font-size: 20px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div class="logo">LOBBY v1.0 | CLICK TO MOVE</div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui-layer">
            <input type="text" id="chat-input" placeholder="Type here to chat..." maxlength="40">
            <button id="chat-btn">SAY</button>
        </div>
    </div>

<script>
/**
 * HIGH QUALITY ISOMETRIC ENGINE
 * Created for the User
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONFIGURATION ---
const TILE_W = 64; // Isometric tile width
const TILE_H = 32; // Isometric tile height
const MAP_SIZE = 12;
const SPEED = 0.08;

// --- ASSETS (Procedural Generation) ---
// We draw assets programmatically to ensure it works without external files.

const PALETTE = {
    floor: '#95a5a6',
    floorHighlight: '#bdc3c7',
    wallLeft: '#7f8c8d',
    wallRight: '#586364',
    wallTop: '#95a5a6',
    skin: '#f1c27d',
    shirt: '#e74c3c',
    pants: '#3498db',
    furniture: '#8e44ad',
    gold: '#f1c40f'
};

// --- GAME STATE ---
let mouse = { x: 0, y: 0, isoX: 0, isoY: 0 };
let map = []; // 0 = Floor, 1 = Wall, 2 = Furniture
let entities = [];
let particles = [];
let bubbles = [];

// Initialize Map
for(let y = 0; y < MAP_SIZE; y++) {
    let row = [];
    for(let x = 0; x < MAP_SIZE; x++) {
        // Create walls on edges
        if (x === 0 || y === 0) row.push(1);
        else if (x === 5 && y === 5) row.push(2); // A "Throne" in the middle
        else row.push(0);
    }
    map.push(row);
}

// --- CLASSES ---

class Entity {
    constructor(x, y, name) {
        this.x = x;
        this.y = y;
        this.z = 0;
        this.targetX = x;
        this.targetY = y;
        this.name = name;
        this.color = PALETTE.shirt;
        this.moving = false;
        this.frame = 0;
        this.path = [];
    }

    update() {
        // Movement Logic
        if (this.path.length > 0) {
            let nextNode = this.path[0];
            let dx = nextNode.x - this.x;
            let dy = nextNode.y - this.y;
            
            if (Math.abs(dx) < SPEED && Math.abs(dy) < SPEED) {
                this.x = nextNode.x;
                this.y = nextNode.y;
                this.path.shift();
            } else {
                this.x += Math.sign(dx) * SPEED;
                this.y += Math.sign(dy) * SPEED;
                this.moving = true;
                this.frame += 0.2;
            }
        } else {
            this.moving = false;
            this.frame = 0;
        }
    }

    draw(ctx, offsetX, offsetY) {
        // Convert Grid to Iso
        const screenX = (this.x - this.y) * (TILE_W / 2) + offsetX;
        const screenY = (this.x + this.y) * (TILE_H / 2) + offsetY;

        // Bobbing animation
        const bounce = this.moving ? Math.abs(Math.sin(this.frame)) * 5 : 0;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(screenX, screenY + TILE_H/2, 15, 7, 0, 0, Math.PI * 2);
        ctx.fill();

        // Draw Avatar (Simple Habbo Style)
        const h = 50; // height
        const w = 24; // width
        const bottomY = screenY + (TILE_H / 2) - bounce;

        // Legs
        ctx.fillStyle = PALETTE.pants;
        ctx.fillRect(screenX - w/2, bottomY - 15, w/2 - 1, 15);
        ctx.fillRect(screenX + 1, bottomY - 15, w/2 - 1, 15);

        // Body
        ctx.fillStyle = this.color;
        ctx.fillRect(screenX - w/2 - 2, bottomY - 35, w + 4, 20);
        
        // Head
        ctx.fillStyle = PALETTE.skin;
        ctx.fillRect(screenX - 10, bottomY - 52, 20, 18);
        
        // Hair/Hat
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(screenX - 11, bottomY - 55, 22, 6);

        // Name tag
        if (!this.moving) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(screenX - 20, bottomY - 75, 40, 14);
            ctx.fillStyle = '#fff';
            ctx.font = '12px "VT323"';
            ctx.textAlign = 'center';
            ctx.fillText(this.name, screenX, bottomY - 64);
        }
    }
}

class ChatBubble {
    constructor(text, x, y) {
        this.text = text;
        this.gridX = x;
        this.gridY = y;
        this.life = 0;
        this.maxLife = 200;
        this.floatOffset = 0;
    }

    update() {
        this.life++;
        this.floatOffset += 0.5;
    }

    draw(ctx, offsetX, offsetY) {
        const screenX = (this.gridX - this.gridY) * (TILE_W / 2) + offsetX;
        const screenY = (this.gridX + this.gridY) * (TILE_H / 2) + offsetY - 80 - this.floatOffset;

        ctx.globalAlpha = 1 - (this.life / this.maxLife);
        
        // Bubble Body
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.roundRect(screenX - 60, screenY - 15, 120, 30, 5);
        ctx.fill();
        
        // Pointer
        ctx.beginPath();
        ctx.moveTo(screenX, screenY + 15);
        ctx.lineTo(screenX - 5, screenY + 20);
        ctx.lineTo(screenX + 5, screenY + 20);
        ctx.fill();

        // Text
        ctx.fillStyle = '#000';
        ctx.font = '16px "VT323"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.text, screenX, screenY);

        ctx.globalAlpha = 1;
    }
}

// --- INITIALIZE PLAYER ---
const player = new Entity(3, 3, "Guest");
entities.push(player);

// --- INPUT HANDLING ---
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});

canvas.addEventListener('mousedown', (e) => {
    // Simple Pathfinding: Just set target to mouse ISO
    // In a full engine, we'd use A* here to avoid walls
    if (mouse.isoX >= 0 && mouse.isoX < MAP_SIZE && mouse.isoY >= 0 && mouse.isoY < MAP_SIZE) {
        if (map[mouse.isoY][mouse.isoX] === 0) {
            // BFS Pathfinding
            player.path = findPath(Math.round(player.x), Math.round(player.y), mouse.isoX, mouse.isoY);
        }
    }
});

const chatInput = document.getElementById('chat-input');
const chatBtn = document.getElementById('chat-btn');

function speak() {
    const text = chatInput.value;
    if(text.trim() === "") return;
    bubbles.push(new ChatBubble(text, player.x, player.y));
    chatInput.value = "";
    // Play subtle sound
    playSound();
}

chatBtn.addEventListener('click', speak);
chatInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') speak(); });

// --- HELPERS ---

function isoToScreen(x, y, offsetX, offsetY) {
    return {
        x: (x - y) * (TILE_W / 2) + offsetX,
        y: (x + y) * (TILE_H / 2) + offsetY
    };
}

function screenToIso(screenX, screenY, offsetX, offsetY) {
    const adjX = screenX - offsetX;
    const adjY = screenY - offsetY;
    const isoY = (2 * adjY - adjX * (TILE_H*2 / TILE_W)) / 2; // Rough approximation logic
    // More precise inversion
    const ym = (2 * (screenY - offsetY)) / TILE_H;
    const xm = (screenX - offsetX) / (TILE_W / 2);
    return {
        x: Math.round((xm + ym) / 2),
        y: Math.round((ym - xm) / 2)
    };
}

function drawBlock(x, y, z, type, offsetX, offsetY, isHovered) {
    const sx = (x - y) * (TILE_W / 2) + offsetX;
    const sy = (x + y) * (TILE_H / 2) + offsetY - (z * TILE_H);

    // Colors
    let cTop, cLeft, cRight;

    if (type === 0) { // Floor
        cTop = isHovered ? '#bdc3c7' : '#95a5a6';
        cLeft = '#7f8c8d';
        cRight = '#7f8c8d';
    } else if (type === 1) { // Wall
        cTop = '#bdc3c7';
        cLeft = '#95a5a6';
        cRight = '#7f8c8d';
    } else if (type === 2) { // Throne (Gold)
        cTop = '#f1c40f';
        cLeft = '#d35400';
        cRight = '#e67e22';
    }

    // Top Face
    ctx.fillStyle = cTop;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(sx + TILE_W / 2, sy - TILE_H / 2);
    ctx.lineTo(sx + TILE_W, sy);
    ctx.lineTo(sx + TILE_W / 2, sy + TILE_H / 2);
    ctx.closePath();
    ctx.fill();
    
    // Highlight edges
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.lineWidth = 1;
    ctx.stroke();

    // 3D Height faces
    let height = type === 0 ? 4 : (type === 2 ? 40 : 100); // Floor thin, Wall tall

    // Right Face
    ctx.fillStyle = cRight;
    ctx.beginPath();
    ctx.moveTo(sx + TILE_W, sy);
    ctx.lineTo(sx + TILE_W / 2, sy + TILE_H / 2);
    ctx.lineTo(sx + TILE_W / 2, sy + TILE_H / 2 + height);
    ctx.lineTo(sx + TILE_W, sy + height);
    ctx.closePath();
    ctx.fill();

    // Left Face
    ctx.fillStyle = cLeft;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(sx + TILE_W / 2, sy + TILE_H / 2);
    ctx.lineTo(sx + TILE_W / 2, sy + TILE_H / 2 + height);
    ctx.lineTo(sx, sy + height);
    ctx.closePath();
    ctx.fill();
}

// Simple BFS for pathfinding
function findPath(sx, sy, ex, ey) {
    let queue = [[{x: sx, y: sy}]];
    let visited = new Set();
    visited.add(`${sx},${sy}`);

    while(queue.length > 0) {
        let path = queue.shift();
        let curr = path[path.length - 1];

        if(curr.x === ex && curr.y === ey) return path.slice(1);

        const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
        
        for(let d of dirs) {
            let nx = curr.x + d.x;
            let ny = curr.y + d.y;
            
            if(nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && 
               map[ny][nx] === 0 && !visited.has(`${nx},${ny}`)) {
                visited.add(`${nx},${ny}`);
                let newPath = [...path, {x: nx, y: ny}];
                queue.push(newPath);
            }
        }
    }
    return [];
}

// Simple synth sound
function playSound() {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
    oscillator.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1);
    
    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}

// --- MAIN LOOP ---

function draw() {
    // Clear Screen
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Camera Center
    const offsetX = canvas.width / 2 - TILE_W / 2;
    const offsetY = 100;

    // Calculate Mouse Hover Logic
    // We reverse engineer screen coord to map coord
    // Since iso logic is tricky to reverse exactly with height, we iterate to find closest tile
    let hoverX = -1, hoverY = -1;
    // Approximation for hit testing
    const mIso = screenToIso(mouse.x, mouse.y, offsetX, offsetY);
    // Clamp
    if(mIso.x >= 0 && mIso.x < MAP_SIZE && mIso.y >= 0 && mIso.y < MAP_SIZE) {
        hoverX = mIso.x;
        hoverY = mIso.y;
    }
    mouse.isoX = hoverX;
    mouse.isoY = hoverY;

    // RENDER LIST (Depth Sorting)
    // We create a list of everything to be drawn (Tiles, Furniture, Entities)
    // Then sort them by their projected depth order
    let renderList = [];

    // 1. Add Tiles & Walls
    for(let y = 0; y < MAP_SIZE; y++) {
        for(let x = 0; x < MAP_SIZE; x++) {
            renderList.push({
                type: 'tile',
                x: x, y: y, z: 0,
                val: map[y][x]
            });
        }
    }

    // 2. Add Entities
    entities.forEach(ent => {
        renderList.push({
            type: 'entity',
            x: ent.x, y: ent.y, z: 0,
            obj: ent
        });
    });

    // 3. Sort logic: (X + Y) is the main depth factor in isometric
    renderList.sort((a, b) => {
        return (a.x + a.y) - (b.x + b.y);
    });

    // 4. Draw Everything
    renderList.forEach(item => {
        if(item.type === 'tile') {
            const isHover = (item.x === hoverX && item.y === hoverY);
            drawBlock(item.x, item.y, item.z, item.val, offsetX, offsetY, isHover);
        } else if (item.type === 'entity') {
            item.obj.update();
            item.obj.draw(ctx, offsetX, offsetY);
        }
    });

    // 5. Draw Chat Bubbles (Always on top)
    for(let i = bubbles.length - 1; i >= 0; i--) {
        let b = bubbles[i];
        b.update();
        b.draw(ctx, offsetX, offsetY);
        if(b.life > b.maxLife) bubbles.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// Start
draw();

</script>
</body>
</html>
