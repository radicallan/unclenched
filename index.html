
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no">
<title>Spirit Board â€” v10 Ideomotor Physics</title>
<style>
  :root{
    --ink:#eaf2ff; --muted:#9fb1c9;
    --header-h:56px; --footer-h:30svh; --safe-b: env(safe-area-inset-bottom, 0px);
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:radial-gradient(1200px 800px at 70% 10%, #111a2a 0%, #0a0f18 50%, #06080d 100%);color:var(--ink);font:15px/1.5 Inter,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial}
  .app{position:relative;min-height:100svh;min-height:100dvh;}
  /* Header */
  header{
    position:fixed; inset:0 0 auto 0; height:var(--header-h);
    display:flex; align-items:center; gap:10px; padding:10px 12px;
    backdrop-filter:saturate(140%) blur(10px);
    background:linear-gradient(180deg, rgba(18,24,36,.65), rgba(10,14,22,.35));
    border-bottom:1px solid rgba(120,160,220,.15); z-index:20;
  }
  .brand{font-weight:600; letter-spacing:.3px; opacity:.85}
  .spacer{flex:1}
  button{
    appearance:none; border:0; cursor:pointer; color:var(--ink); font-weight:600; letter-spacing:.2px;
    padding:10px 14px; border-radius:12px;
    background:linear-gradient(180deg, rgba(30,50,80,.9), rgba(24,38,64,.85));
    box-shadow: 0 1px 0 rgba(255,255,255,.05) inset, 0 10px 30px rgba(4,12,24,.35);
    transition: transform .08s ease, box-shadow .2s ease, filter .2s ease;
  }
  .btn-accent{
    background:linear-gradient(180deg, rgba(40,120,200,.95), rgba(24,64,110,.95));
    box-shadow: 0 1px 0 rgba(255,255,255,.08) inset, 0 10px 32px rgba(20,110,190,.35);
  }
  /* Stage */
  #stageWrap{ position:fixed; left:0; right:0; top:var(--header-h); bottom:calc(var(--footer-h) + var(--safe-b)); }
  #cv{ position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; -webkit-user-select:none; user-select:none; filter: drop-shadow(0 50px 60px rgba(60,150,230,.06)); }
  /* Footer transcript */
  footer{
    position:fixed; left:0; right:0; bottom:0; height:calc(var(--footer-h) + var(--safe-b));
    background:linear-gradient(180deg, rgba(12,16,26,.9), rgba(9,12,20,.96));
    border-top:1px solid rgba(120,160,220,.12);
    padding:10px 12px calc(10px + var(--safe-b)) 12px; z-index:20; backdrop-filter:saturate(140%) blur(10px);
  }
  label.caption{display:block; font-size:12px; color:var(--muted); margin:0 0 6px 2px; letter-spacing:.2px}
  textarea#ta{
    width:100%; height:calc(100% - 24px);
    background:linear-gradient(180deg,#0a0f18,#0a0e16);
    color:var(--ink); border:1px solid rgba(120,160,220,.18); border-radius:14px; padding:12px 14px;
    resize:none; font-family:ui-monospace,Menlo,Consolas,monospace; box-shadow: inset 0 10px 30px rgba(0,0,0,.25);
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">Spirit Board</div>
    <div class="spacer"></div>
    <button id="btnRefresh" class="btn-accent" aria-label="Refresh session">Refresh</button>
    <button id="btnGoodbye" aria-label="End session">Goodbye</button>
  </header>

  <div id="stageWrap"><canvas id="cv"></canvas></div>

  <footer>
    <label class="caption" for="ta">Transcript</label>
    <textarea id="ta" readonly>(no text)</textarea>
  </footer>
</div>

<script>
(function(){
  const $=s=>document.querySelector(s);
  const cv=$('#cv'), ctx=cv.getContext('2d',{alpha:true});
  const ta=$('#ta');
  const DPR=Math.min(2, window.devicePixelRatio||1);
  let W=0,H=0, running=true, message="";
  // Timing + board
  const DWELL_MS=700, tileScale=1.15, planRpx=22, arcTight=0.86;
  const IN_FACTOR=1.22, OUT_FACTOR=1.60;
  const MIN_GAP=240, REPEAT_CD=700;
  // Physics
  const MASS=1.0, FRICTION=0.90;           // velocity damping per frame (~60 FPS)
  const G_USER=0.010;                       // user force gain
  const G_CONSENSUS=0.020;                  // extra gain when directions agree
  const G_WELL=0.008;                       // letter attraction
  const WELL_RADIUS=120;                    // influence radius in canvas pixels (before DPR)
  const DRIFT_AMPL=0.35;                    // sub-pixel micro drift amplitude
  const DRIFT_FREQ=0.16;                    // Hz
  // Shared planchette
  const plan={x:0,y:0,r:Math.max(16*DPR, planRpx*DPR), trail:[], vx:0, vy:0};
  // Touches id -> {x,y, vx, vy}
  const touches=new Map();
  // Dwell / commit
  const tiles=[]; let entered=null, ready=0; let lastCommit=null;

  // Canvas sizing
  function sizeCanvas(){
    const wrap=document.getElementById('stageWrap'), r=wrap.getBoundingClientRect();
    const w=Math.max(50, Math.floor(r.width*DPR)), h=Math.max(50, Math.floor(r.height*DPR));
    if(cv.width!==w) cv.width=w;
    if(cv.height!==h) cv.height=h;
    W=cv.width; H=cv.height;
    buildTiles(); center(); draw();
  }
  new ResizeObserver(sizeCanvas).observe(document.getElementById('stageWrap'));
  window.addEventListener('orientationchange', ()=>{ setTimeout(sizeCanvas, 250); setTimeout(sizeCanvas, 800); });
  window.addEventListener('resize', ()=>{ setTimeout(sizeCanvas, 150); });
  setTimeout(sizeCanvas, 60); setTimeout(sizeCanvas, 300); setTimeout(sizeCanvas, 900);

  function center(){ plan.x=W*0.52; plan.y=H*0.62; plan.vx=0; plan.vy=0; draw(); }

  // Layout
  function buildTiles(){
    tiles.length=0;
    const cx=W*0.52, cy=H*0.62, baseR=Math.min(W,H)*0.36;
    const a0 = -Math.PI*(arcTight), a1 = -Math.PI*(1.0-arcTight);
    const ring=(arr,r,idPrefix)=>{
      const n=arr.length;
      for(let i=0;i<n;i++){
        const t=i/(n-1), ang=a0+(a1-a0)*t, x=cx+Math.cos(ang)*r, y=cy+Math.sin(ang)*r;
        tiles.push({x,y,r:Math.min(W,H)*0.035*tileScale,label:arr[i], id:idPrefix+i});
      }
    };
    const r1=[...'ABCDEFGH'], r2=[...'IJKLMNOP'], r3=[...'QRSTUVWXYZ'], nums=[...'1234567890'], cor=['YES','NO','GOODBYE'];
    ring(r1, baseR*0.70, 'r1-'); ring(r2, baseR*0.90, 'r2-'); ring(r3, baseR*1.10, 'r3-');
    const nbY=cy+baseR*0.62, nr=Math.min(W,H)*0.035*tileScale;
    for(let i=0;i<nums.length;i++){ const x=(W*0.20)+i*(W*0.6/(nums.length-1)); tiles.push({x,y:nbY,r:nr,label:nums[i], id:'n-'+i}); }
    tiles.push({x:W*0.18,y:H*0.16,r:Math.min(W,H)*0.045*tileScale,label:'YES', id:'y'});
    tiles.push({x:W*0.82,y:H*0.16,r:Math.min(W,H)*0.045*tileScale,label:'NO', id:'n'});
    tiles.push({x:W*0.50,y:H*0.16,r:Math.min(W,H)*0.045*tileScale,label:'GOODBYE', id:'g'});
  }

  // Drawing
  function drawBoard(){
    ctx.clearRect(0,0,W,H);
    const g=ctx.createRadialGradient(W*0.62,H*0.30,10, W*0.62,H*0.30, Math.max(W,H)*0.9);
    g.addColorStop(0,'rgba(120,200,255,0.07)'); g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.lineWidth=1;
    for(let y=0;y<H;y+=Math.max(24, 26*DPR)){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke(); }
    for(let x=0;x<W;x+=Math.max(24, 26*DPR)){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,H); ctx.stroke(); }
    ctx.strokeStyle='rgba(200,210,230,0.10)'; ctx.lineWidth=Math.max(1, Math.min(W,H)*0.002);
    const cx=W*0.52, cy=H*0.62, baseR=Math.min(W,H)*0.36;
    [0.70, 0.90, 1.10].forEach(m=>{ ctx.beginPath(); ctx.arc(cx,cy,baseR*m,0,Math.PI*2); ctx.stroke(); });
    ctx.textAlign='center'; ctx.textBaseline='middle';
    const fontBig=(Math.min(W,H)*0.048)+'px ui-monospace,Menlo,Consolas';
    const fontCor=(Math.min(W,H)*0.039)+'px ui-monospace,Menlo,Consolas';
    for(const t of tiles){
      if(t.label.length===1){ ctx.fillStyle='rgba(220,230,250,.98)'; ctx.font=fontBig; }
      else if(t.label==='YES'){ ctx.fillStyle='rgba(157,246,178,.98)'; ctx.font=fontCor; }
      else if(t.label==='NO'){ ctx.fillStyle='rgba(255,178,178,.98)'; ctx.font=fontCor; }
      else { ctx.fillStyle='rgba(160,175,195,.98)'; ctx.font=fontCor; }
      ctx.shadowColor='rgba(126,227,255,0.12)'; ctx.shadowBlur=8;
      ctx.fillText(t.label, t.x, t.y);
      ctx.shadowBlur=0;
    }
    if(entered && entered.tile){
      const t=entered.tile, pct=ready;
      ctx.lineWidth=5; ctx.strokeStyle = (pct>=1 ? 'rgba(157,246,178,0.95)' : 'rgba(122,225,255,0.75)');
      ctx.beginPath(); ctx.arc(t.x, t.y, t.r*1.2, -Math.PI/2, (-Math.PI/2)+pct*2*Math.PI); ctx.stroke();
    }
  }
  function drawPlanchette(){
    const r=plan.r, x=plan.x, y=plan.y;
    ctx.strokeStyle='rgba(122,225,255,0.22)'; ctx.lineWidth=2;
    ctx.beginPath(); for(let i=0;i<plan.trail.length;i++){ const p=plan.trail[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke();
    ctx.fillStyle='rgba(14,22,36,0.92)'; ctx.strokeStyle='rgba(70,140,220,0.85)'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.ellipse(x,y,r*1.05,r*0.95,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle='rgba(255,255,255,0.10)'; ctx.beginPath(); ctx.arc(x,y,r*0.36,0,Math.PI*2); ctx.fill();
  }
  function draw(){ drawBoard(); drawPlanchette(); }

  // Helpers
  function toCanvas(clientX,clientY){ const r=cv.getBoundingClientRect(); return {x:(clientX-r.left)*DPR, y:(clientY-r.top)*DPR}; }
  function hit(x,y){ for(const t of tiles){ if(Math.hypot(x-t.x,y-t.y)<=t.r) return t; } return null; }
  function stickyHit(x,y){
    if(entered && entered.tile){
      const d=Math.hypot(x-entered.tile.x,y-entered.tile.y);
      if(d <= entered.tile.r*OUT_FACTOR) return entered.tile;
    }
    return hit(x,y);
  }

  // Consensus gain based on alignment of touch velocity directions
  function consensusBoost(){
    const vs=[];
    for(const [,p] of touches){ if(p.vx||p.vy){ const m=Math.hypot(p.vx,p.vy); if(m>0.02) vs.push({x:p.vx/m, y:p.vy/m}); } }
    if(vs.length<2) return 0;
    // Mean resultant length as alignment measure
    let sx=0, sy=0; for(const v of vs){ sx+=v.x; sy+=v.y; }
    const R = Math.hypot(sx,sy)/vs.length; // 0..1
    return R; // 0=no agreement, 1=perfect alignment
  }

  // Attraction field toward nearest tile (soft well)
  function attractionForce(px,py){
    let best=null, bd=1e9;
    for(const t of tiles){
      const dx=t.x-px, dy=t.y-py; const d=Math.hypot(dx,dy);
      if(d<bd){ bd=d; best={t,dx,dy,d}; }
    }
    if(!best) return {fx:0,fy:0};
    const R = WELL_RADIUS*DPR;
    if(best.d>R) return {fx:0,fy:0};
    const k = G_WELL * Math.exp(- (best.d*best.d)/(2*(0.45*R)*(0.45*R)) ); // Gaussian falloff
    return {fx:k*best.dx, fy:k*best.dy};
  }

  // Transcript & commit
  function canCommit(tile, now){
    if(!entered || !entered.ready) return false;
    if(lastCommit){
      if(lastCommit.id===tile.id && (now-lastCommit.t) < REPEAT_CD) return false;
      if((now - lastCommit.t) < MIN_GAP) return false;
    }
    return true;
  }
  function commit(tile){
    const now=performance.now();
    if(!canCommit(tile, now)) return;
    const lab=tile.label;
    if(lab==='GOODBYE'){ message+=' [GOODBYE]'; running=false; }
    else if(lab==='YES' || lab==='NO'){ message+=` [${lab}]`; }
    else if(lab.length===1){ message+=lab; }
    lastCommit={id:tile.id, t:now};
    entered && (entered.didCommit=true);
    updateTranscript();
  }
  function updateTranscript(){ ta.value=message||'(no text)'; ta.scrollTop=ta.scrollHeight; }

  // Animation
  let lastTs=performance.now(); let driftPhase=0;
  function tick(ts){
    const dt=(ts-lastTs)||16; lastTs=ts;
    const dtSec = dt/1000;
    // Estimate per-touch velocity & centroid
    let cx=0, cy=0, n=0;
    for(const [id,p] of touches){
      if(p.px===undefined){ p.px=p.x; p.py=p.y; p.vx=0; p.vy=0; }
      const vx=(p.x - p.px)/dt; const vy=(p.y - p.py)/dt;
      p.vx = 0.6*p.vx + 0.4*vx; p.vy = 0.6*p.vy + 0.4*vy; // smooth
      p.px=p.x; p.py=p.y;
      cx+=p.x; cy+=p.y; n++;
    }
    let fx=0, fy=0;
    if(n>0){
      cx/=n; cy/=n;
      // User force tends to pull planchette toward centroid (spring-like)
      const ux = cx - plan.x, uy = cy - plan.y;
      let gain = G_USER;
      // Consensus adds gentle amplification
      gain += G_CONSENSUS * consensusBoost();
      fx += gain * ux;
      fy += gain * uy;
    } else {
      // No touches: slow to a stop
    }

    // Attraction toward nearest tile (soft, short range)
    const well = attractionForce(plan.x, plan.y);
    fx += well.fx; fy += well.fy;

    // Micro drift when almost still & at least one touch is down (ideomotor feel)
    const totalSpeed = Math.hypot(plan.vx, plan.vy);
    const touchDown = n>0;
    if(touchDown && totalSpeed < 0.02){
      driftPhase += dtSec * (2*Math.PI*DRIFT_FREQ);
      fx += (DRIFT_AMPL*Math.cos(driftPhase))/1000;
      fy += (DRIFT_AMPL*Math.sin(driftPhase))/1000;
    }

    // Integrate physics
    plan.vx = plan.vx*FRICTION + (fx/MASS);
    plan.vy = plan.vy*FRICTION + (fy/MASS);
    plan.x += plan.vx * dt;
    plan.y += plan.vy * dt;

    // Keep inside
    plan.x = Math.max(0, Math.min(W, plan.x));
    plan.y = Math.max(0, Math.min(H, plan.y));

    // Trail
    plan.trail.push({x:plan.x,y:plan.y}); if(plan.trail.length>600) plan.trail.shift();

    // Dwell/commit at current position
    const tile=stickyHit(plan.x, plan.y);
    if(tile && (!entered || entered.tile!==tile)){
      entered={tile, tEnter:ts, ready:false, didCommit:false}; ready=0;
    }
    if(tile){
      ready = Math.min(1, (ts - entered.tEnter) / DWELL_MS);
      entered.ready = ready >= 1;
      if(entered.ready && !entered.didCommit) commit(tile);
    }else{
      entered=null; ready=0;
    }

    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Touch handlers (multi-person shared planchette)
  function toCanvas(clientX,clientY){ const r=cv.getBoundingClientRect(); return {x:(clientX-r.left)*DPR, y:(clientY-r.top)*DPR}; }
  cv.addEventListener('touchstart', e=>{
    e.preventDefault();
    for(const t of e.changedTouches){ const p=toCanvas(t.clientX,t.clientY); touches.set(t.identifier, p); }
  }, {passive:false});
  cv.addEventListener('touchmove', e=>{
    e.preventDefault();
    for(const t of e.changedTouches){ const p=toCanvas(t.clientX,t.clientY); touches.set(t.identifier, p); }
  }, {passive:false});
  function endTouches(list){ for(const t of list){ touches.delete(t.identifier); } }
  cv.addEventListener('touchend', e=>{ e.preventDefault(); endTouches(e.changedTouches); }, {passive:false});
  cv.addEventListener('touchcancel', e=>{ e.preventDefault(); endTouches(e.changedTouches); }, {passive:false});
  // Mouse for desktop
  let mouseDown=false;
  cv.addEventListener('mousedown', e=>{ mouseDown=true; touches.set('mouse', toCanvas(e.clientX,e.clientY)); });
  cv.addEventListener('mousemove', e=>{ if(mouseDown) touches.set('mouse', toCanvas(e.clientX,e.clientY)); });
  cv.addEventListener('mouseup', e=>{ mouseDown=false; touches.delete('mouse'); });

  // Buttons
  $('#btnRefresh').onclick=()=>{
    running=true; message=''; ta.value='(no text)';
    plan.trail.length=0; entered=null; ready=0; lastCommit=null; plan.vx=0; plan.vy=0;
  };
  $('#btnGoodbye').onclick=()=>{
    if(!running) return;
    message+=' [GOODBYE]'; running=false; updateTranscript();
  };

  // Init
  sizeCanvas(); updateTranscript();
})();
</script>
</body>
</html>
