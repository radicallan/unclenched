<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IsoSocial — Habbo-inspired Isometric Room (Offline)</title>
  <style>
    :root{
      --bg:#0b0b0c;
      --panel:#101012;
      --line:#242428;
      --text:#e9e9ee;
      --muted:#a7a7b2;
      --good:#7ef0b3;
      --warn:#ffcf66;
      --bad:#ff6b6b;
      --accent:#ffffff;
      --shadow: rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 700px at 50% -10%, #1a1a1f, var(--bg));
      color:var(--text);
      height:100vh;
      overflow:hidden;
    }
    .app{
      display:grid;
      grid-template-columns: 290px 1fr 320px;
      grid-template-rows: 56px 1fr 92px;
      gap:0;
      height:100vh;
    }
    header{
      grid-column:1/-1;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 14px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(#0f0f12, #0b0b0c);
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:260px;
    }
    .logo{
      width:34px;height:34px;border-radius:10px;
      border:1px solid var(--line);
      background: linear-gradient(145deg, #1f1f27, #0f0f12);
      display:grid;place-items:center;
      box-shadow: 0 8px 22px var(--shadow);
      font-weight:800;
    }
    .brand h1{
      font-size:14px;
      margin:0;
      letter-spacing:.4px;
    }
    .brand .sub{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }
    .top-actions{
      display:flex; align-items:center; gap:10px;
    }
    .pill{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.03);
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }
    .btn{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.04);
      color:var(--text);
      border-radius:10px;
      padding:10px 12px;
      font-weight:650;
      font-size:12px;
      cursor:pointer;
    }
    .btn:hover{ background: rgba(255,255,255,0.07); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: rgba(255,255,255,0.10);
      border-color:#2f2f35;
    }
    .btn.tiny{ padding:7px 10px; border-radius:999px; font-weight:600; }
    aside{
      background: rgba(255,255,255,0.02);
      border-right:1px solid var(--line);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-width:260px;
    }
    aside.right{
      border-right:none;
      border-left:1px solid var(--line);
      min-width:280px;
    }
    .panel{
      padding:12px;
      border-bottom:1px solid var(--line);
    }
    .panel h2{
      margin:0 0 10px 0;
      font-size:12px;
      letter-spacing:.35px;
      color:var(--muted);
      font-weight:700;
      text-transform:uppercase;
    }
    .list{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height: calc(100vh - 56px - 92px - 24px);
      overflow:auto;
      padding-right:4px;
    }
    .card{
      border:1px solid var(--line);
      background: rgba(255,255,255,0.03);
      border-radius:12px;
      padding:10px;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .muted{ color:var(--muted); }
    .small{ font-size:12px; }
    .tiny{ font-size:11px; }
    .divider{
      height:1px; background: var(--line); margin:10px 0;
    }
    .tag{
      font-size:11px;
      color:var(--muted);
      border:1px solid var(--line);
      padding:4px 8px;
      border-radius:999px;
      background: rgba(255,255,255,0.02);
      user-select:none;
      white-space:nowrap;
    }
    main{
      position:relative;
      background: radial-gradient(900px 500px at 55% 30%, rgba(255,255,255,0.06), rgba(0,0,0,0));
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }
    .hud{
      position:absolute;
      left:12px; top:12px;
      display:flex;
      gap:8px;
      z-index:5;
      flex-wrap:wrap;
      max-width: calc(100% - 24px);
    }
    .toast{
      position:absolute;
      right:12px; top:12px;
      z-index:6;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
      pointer-events:none;
    }
    .toast .t{
      pointer-events:none;
      border:1px solid var(--line);
      background: rgba(16,16,18,0.88);
      backdrop-filter: blur(8px);
      padding:10px 12px;
      border-radius:12px;
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      font-size:12px;
      color:var(--text);
      max-width:320px;
    }
    .t.good{ border-color: rgba(126,240,179,.35); }
    .t.warn{ border-color: rgba(255,207,102,.35); }
    .t.bad{ border-color: rgba(255,107,107,.35); }

    footer{
      grid-column:1/-1;
      border-top:1px solid var(--line);
      background: rgba(8,8,10,0.96);
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:10px;
      padding:10px 12px;
      align-items:stretch;
    }
    .chatbox{
      display:flex;
      gap:10px;
      align-items:stretch;
      min-width:0;
    }
    .chatlog{
      flex:1;
      min-width:0;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.03);
      border-radius:12px;
      padding:10px;
      overflow:auto;
      font-size:12px;
      line-height:1.45;
      max-height:72px;
    }
    .chatlog b{ color:var(--accent); }
    .chatlog .sys{ color: var(--muted); }
    .chatinput{
      display:flex;
      gap:8px;
      align-items:center;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.03);
      border-radius:12px;
      padding:8px;
      min-width:0;
    }
    input[type="text"]{
      width:100%;
      border:none;
      outline:none;
      background:transparent;
      color:var(--text);
      font-size:13px;
      min-width:0;
    }
    .rightbar{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      align-items:center;
    }
    .kbd{
      font-size:11px; color:var(--muted);
      border:1px solid var(--line);
      padding:4px 8px;
      border-radius:999px;
      background: rgba(255,255,255,0.02);
      user-select:none;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }

    .item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:12px;
      background: rgba(255,255,255,0.02);
      cursor:pointer;
      user-select:none;
    }
    .item:hover{ background: rgba(255,255,255,0.05); }
    .item.active{
      outline:2px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
    }
    .item .meta{
      display:flex; flex-direction:column; gap:2px;
      min-width:0;
    }
    .item .meta .name{
      font-size:12px; font-weight:700;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .item .meta .desc{
      font-size:11px; color:var(--muted);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .badge{
      font-size:11px; color:var(--muted);
      border:1px solid var(--line);
      padding:4px 8px;
      border-radius:999px;
      white-space:nowrap;
    }

    /* Responsive */
    @media (max-width: 1100px){
      .app{ grid-template-columns: 260px 1fr; grid-template-rows:56px 1fr 92px; }
      aside.right{ display:none; }
      footer{ grid-template-columns: 1fr; }
      .rightbar{ justify-content:space-between; }
    }
    @media (max-width: 820px){
      .app{ grid-template-columns: 1fr; }
      aside{ display:none; }
      footer{ padding:10px; }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <div class="logo">IS</div>
      <div>
        <h1>IsoSocial</h1>
        <div class="sub">Habbo-inspired isometric room • offline • original assets</div>
      </div>
    </div>
    <div class="top-actions">
      <div class="pill" id="statusPill">Loading…</div>
      <button class="btn tiny" id="btnHelp">Commands</button>
      <button class="btn tiny" id="btnSave">Save</button>
      <button class="btn tiny" id="btnLoad">Load</button>
      <button class="btn tiny" id="btnExport">Export</button>
      <button class="btn tiny" id="btnImport">Import</button>
      <button class="btn tiny" id="btnSound">Sound: On</button>
      <button class="btn tiny primary" id="btnBuild">Build: Off</button>
    </div>
  </header>

  <aside>
    <div class="panel">
      <h2>Rooms</h2>
      <div class="list" id="roomList"></div>
    </div>

    <div class="panel">
      <h2>Stats</h2>
      <div class="card">
        <div class="row"><span class="muted small">Name</span><span class="small" id="statName"></span></div>
        <div class="row"><span class="muted small">Pixels</span><span class="small" id="statPixels"></span></div>
        <div class="row"><span class="muted small">Steps</span><span class="small" id="statSteps"></span></div>
        <div class="row"><span class="muted small">Room</span><span class="small" id="statRoom"></span></div>
        <div class="divider"></div>
        <div class="row"><span class="muted small">Achievement</span><span class="small" id="statAch"></span></div>
      </div>
    </div>

    <div class="panel">
      <h2>Minimap</h2>
      <div class="card">
        <canvas id="minimap" width="260" height="160" style="width:100%;height:auto;border-radius:10px;border:1px solid var(--line);background:rgba(255,255,255,0.02)"></canvas>
      </div>
      <div class="tiny muted" style="margin-top:8px">
        Click a tile to walk. In build mode: select item → click tile to place.
      </div>
    </div>
  </aside>

  <main>
    <div class="hud">
      <div class="pill" id="hudTip">Tip: click to walk • /help for commands • build mode places furniture</div>
      <div class="pill" id="hudQuest">Quest: —</div>
    </div>
    <div class="toast" id="toast"></div>
    <canvas id="game"></canvas>
  </main>

  <aside class="right">
    <div class="panel">
      <h2>Inventory</h2>
      <div class="list" id="invList"></div>
    </div>

    <div class="panel">
      <h2>Shop</h2>
      <div class="grid2" id="shopGrid"></div>
      <div class="tiny muted" style="margin-top:10px">
        Earn pixels from quests + achievements. Items placeable in build mode.
      </div>
    </div>

    <div class="panel">
      <h2>People</h2>
      <div class="card">
        <div class="row">
          <span class="tag">You</span>
          <span class="small">+ NPCs</span>
        </div>
        <div class="divider"></div>
        <div class="tiny muted">
          This is a single-player “social room” sandbox — you can extend it to multiplayer with WebSockets.
        </div>
      </div>
    </div>
  </aside>

  <footer>
    <div class="chatbox">
      <div class="chatlog" id="chatlog"></div>
      <div class="chatinput">
        <input id="chat" type="text" autocomplete="off" placeholder="Type message… (try /help, /dance, /quest, /buy sofa, /place sofa)" />
        <button class="btn" id="btnSend">Send</button>
      </div>
    </div>
    <div class="rightbar">
      <span class="kbd">R rotate</span>
      <span class="kbd">Esc cancel</span>
      <span class="kbd">WASD pan</span>
      <span class="kbd">Mouse wheel zoom</span>
    </div>
  </footer>
</div>

<script>
(() => {
  "use strict";

  /* -----------------------------
     Utilities
  ------------------------------*/
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const now = ()=>performance.now();
  const fmtTime = () => {
    const d = new Date();
    const h = String(d.getHours()).padStart(2,"0");
    const m = String(d.getMinutes()).padStart(2,"0");
    return `${h}:${m}`;
  };

  function makeId(prefix="id"){
    return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  function deepClone(obj){
    return JSON.parse(JSON.stringify(obj));
  }

  /* -----------------------------
     Toasts + Audio
  ------------------------------*/
  const toastEl = document.getElementById("toast");
  function toast(msg, kind="good", ms=2200){
    const div = document.createElement("div");
    div.className = `t ${kind}`;
    div.textContent = msg;
    toastEl.appendChild(div);
    setTimeout(()=> {
      div.style.opacity = "0";
      div.style.transform = "translateY(-6px)";
      div.style.transition = "opacity .25s ease, transform .25s ease";
      setTimeout(()=> div.remove(), 260);
    }, ms);
  }

  let soundOn = true;
  let audioCtx = null;
  function beep(freq=660, dur=0.06, type="sine", gain=0.03){
    if(!soundOn) return;
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }

  /* -----------------------------
     Game config
  ------------------------------*/
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const mini = document.getElementById("minimap");
  const mctx = mini.getContext("2d");

  // Isometric tile geometry
  const TILE_W = 56;
  const TILE_H = 28;
  const HEIGHT_UNIT = 12;  // pixels per "z" height
  const MAX_STEP = 1;      // max climb per move

  // Camera
  const camera = {
    x: 0,
    y: 0,
    zoom: 1,
    targetZoom: 1,
    panSpeed: 520, // px/s
  };

  // UI
  const statusPill = document.getElementById("statusPill");
  const hudQuest = document.getElementById("hudQuest");
  const invList = document.getElementById("invList");
  const shopGrid = document.getElementById("shopGrid");
  const roomList = document.getElementById("roomList");
  const chatlog = document.getElementById("chatlog");
  const chatInput = document.getElementById("chat");
  const btnSend = document.getElementById("btnSend");
  const btnBuild = document.getElementById("btnBuild");
  const btnSave = document.getElementById("btnSave");
  const btnLoad = document.getElementById("btnLoad");
  const btnExport = document.getElementById("btnExport");
  const btnImport = document.getElementById("btnImport");
  const btnHelp = document.getElementById("btnHelp");
  const btnSound = document.getElementById("btnSound");

  const statName = document.getElementById("statName");
  const statPixels = document.getElementById("statPixels");
  const statSteps = document.getElementById("statSteps");
  const statRoom = document.getElementById("statRoom");
  const statAch = document.getElementById("statAch");

  /* -----------------------------
     Data: furniture types
  ------------------------------*/
  const FURNI = {
    sofa:   { key:"sofa",   name:"Sofa",   desc:"Sit + chill", price:35, w:1, h:1, blocks:false, sit:true,  color:"#d6d6de" },
    plant:  { key:"plant",  name:"Plant",  desc:"Vibes",       price:18, w:1, h:1, blocks:true,  sit:false, color:"#9fe2b1" },
    rug:    { key:"rug",    name:"Rug",    desc:"Soft step",   price:22, w:1, h:1, blocks:false, sit:false, color:"#cbb9ff" },
    lamp:   { key:"lamp",   name:"Lamp",   desc:"Warm light",  price:28, w:1, h:1, blocks:true,  sit:false, color:"#ffd28a" },
    table:  { key:"table",  name:"Table",  desc:"Meet here",   price:26, w:1, h:1, blocks:true,  sit:false, color:"#c8c8c8" },
    poster: { key:"poster", name:"Poster", desc:"Wall deco",   price:16, w:1, h:1, blocks:false, sit:false, color:"#9bbcff", wall:true },
    arcade: { key:"arcade", name:"Arcade", desc:"Beep boop",   price:55, w:1, h:1, blocks:true,  sit:false, color:"#ff86c4" }
  };

  const SHOP = [
    "sofa","plant","rug","lamp","table","poster","arcade"
  ];

  /* -----------------------------
     Rooms: tile maps (heights + walkable)
  ------------------------------*/
  function makeRoom({
    key, name, w, h, heights, walls, spawn, decor
  }){
    return { key, name, w, h, heights, walls, spawn, decor };
  }

  function flatHeights(w,h, base=0){
    const a = new Array(w*h).fill(base);
    return a;
  }

  function idx(w,x,y){ return y*w + x; }

  // Generate a cozy lounge with a raised platform
  function loungeRoom(){
    const w=12, h=12;
    const heights = flatHeights(w,h,0);

    // Raised stage
    for(let y=3;y<=8;y++){
      for(let x=6;x<=9;x++){
        heights[idx(w,x,y)] = 1;
      }
    }
    // Tiny slope edges
    heights[idx(w,6,3)] = 0;
    heights[idx(w,6,8)] = 0;

    // Walls mask (true = not part of floor)
    const walls = new Array(w*h).fill(false);
    // cut corners
    walls[idx(w,0,0)] = true; walls[idx(w,11,0)] = true;
    walls[idx(w,0,11)] = true; walls[idx(w,11,11)] = true;

    const decor = [
      { id:makeId("f"), type:"sofa", x:3,y:7, rot:0 },
      { id:makeId("f"), type:"table", x:3,y:6, rot:0 },
      { id:makeId("f"), type:"lamp", x:2,y:6, rot:0 },
      { id:makeId("f"), type:"plant", x:9,y:4, rot:0 },
      { id:makeId("f"), type:"arcade", x:7,y:6, rot:0 },
      { id:makeId("f"), type:"rug", x:4,y:6, rot:0 }
    ];

    return makeRoom({
      key:"lounge",
      name:"The Lounge",
      w,h,
      heights,
      walls,
      spawn:{x:2,y:2},
      decor
    });
  }

  // A tiny courtyard with varied heights
  function courtyardRoom(){
    const w=14, h=10;
    const heights = flatHeights(w,h,0);
    const walls = new Array(w*h).fill(false);

    // Shape it: remove a little top-left chunk
    for(let y=0;y<2;y++){
      for(let x=0;x<2;x++){
        walls[idx(w,x,y)]=true;
      }
    }

    // Make a little hill
    const hill = [
      [8,4,1],[9,4,1],[10,4,1],
      [8,5,1],[9,5,2],[10,5,1],
      [8,6,1],[9,6,1],[10,6,1]
    ];
    for(const [x,y,z] of hill){
      heights[idx(w,x,y)] = z;
    }

    const decor = [
      { id:makeId("f"), type:"plant", x:5,y:7, rot:0 },
      { id:makeId("f"), type:"plant", x:6,y:7, rot:0 },
      { id:makeId("f"), type:"lamp", x:12,y:2, rot:0 },
      { id:makeId("f"), type:"rug", x:3,y:4, rot:0 }
    ];

    return makeRoom({
      key:"courtyard",
      name:"Courtyard",
      w,h, heights, walls,
      spawn:{x:3,y:2},
      decor
    });
  }

  // Workshop: more “grid-like” for building
  function workshopRoom(){
    const w=16, h=12;
    const heights = flatHeights(w,h,0);
    const walls = new Array(w*h).fill(false);

    // border cut
    for(let x=0;x<w;x++){
      walls[idx(w,x,0)]=true;
      walls[idx(w,x,h-1)]=true;
    }
    for(let y=0;y<h;y++){
      walls[idx(w,0,y)]=true;
      walls[idx(w,w-1,y)]=true;
    }

    const decor = [
      { id:makeId("f"), type:"table", x:4,y:4, rot:0 },
      { id:makeId("f"), type:"arcade", x:6,y:4, rot:0 },
      { id:makeId("f"), type:"sofa", x:4,y:6, rot:0 },
      { id:makeId("f"), type:"lamp", x:6,y:6, rot:0 }
    ];

    return makeRoom({
      key:"workshop",
      name:"Workshop",
      w,h, heights, walls,
      spawn:{x:2,y:2},
      decor
    });
  }

  const ROOMS = {
    lounge: loungeRoom(),
    courtyard: courtyardRoom(),
    workshop: workshopRoom(),
  };

  /* -----------------------------
     Game State
  ------------------------------*/
  const state = {
    version: "1.0",
    buildMode: false,
    selectedItemKey: null,
    rotate: 0,
    steps: 0,
    pixels: 90,
    roomKey: "lounge",
    // Placed furniture is per-room (clone room decor into runtime)
    roomFurni: {},

    // Achievements
    ach: {
      firstChat: false,
      walked100: false,
      placed10: false,
      questDone: false
    },

    // Quest
    quest: {
      active: true,
      id: "coffee_run",
      stage: 0, // 0=go NPC, 1=go arcade, 2=return
      done: false
    }
  };

  // Player + NPCs
  const entities = {
    player: {
      id:"player",
      name: "Allan",
      color: "#ffffff",
      x: 2, y: 2, z: 0,
      px: 0, py: 0, pz: 0, // rendered (interpolated)
      moving: false,
      path: [],
      t: 0,
      dir: 0,
      emote: null,
      emoteUntil: 0,
      sit: null, // {x,y} if sitting
      bubble: null, // {text, until}
    },
    npcs: [
      {
        id:"npc_bean",
        name:"Bean",
        role:"Barista NPC",
        color:"#ffcf66",
        x: 4, y: 3, z: 0,
        bubble:null
      },
      {
        id:"npc_ivy",
        name:"Ivy",
        role:"Guide NPC",
        color:"#9fe2b1",
        x: 8, y: 7, z: 1, // on stage in lounge
        bubble:null
      }
    ]
  };

  // Runtime: room, obstacles, etc.
  const runtime = {
    room: null,
    furni: [],
    // For placement previews
    placing: null, // {typeKey, x,y, ok}
    // Day/night cycle
    timeOfDay: 0, // 0..1
    // Speech bubbles list (ephemeral)
    bubbles: [],
    // Notifications
    lastTick: now(),
    fps: 0,
  };

  /* -----------------------------
     Local Storage Save
  ------------------------------*/
  const SAVE_KEY = "isosocial_save_v1";

  function buildSaveBlob(){
    return {
      version: state.version,
      buildMode: state.buildMode,
      selectedItemKey: state.selectedItemKey,
      rotate: state.rotate,
      steps: state.steps,
      pixels: state.pixels,
      roomKey: state.roomKey,
      roomFurni: state.roomFurni,
      ach: state.ach,
      quest: state.quest,
      player: {
        name: entities.player.name,
        color: entities.player.color,
        x: entities.player.x,
        y: entities.player.y
      }
    };
  }

  function applySaveBlob(blob){
    if(!blob || typeof blob !== "object") throw new Error("Invalid save.");
    state.buildMode = !!blob.buildMode;
    state.selectedItemKey = blob.selectedItemKey ?? null;
    state.rotate = blob.rotate ?? 0;
    state.steps = blob.steps ?? 0;
    state.pixels = blob.pixels ?? 0;
    state.roomKey = blob.roomKey ?? "lounge";
    state.roomFurni = blob.roomFurni ?? {};
    state.ach = blob.ach ?? state.ach;
    state.quest = blob.quest ?? state.quest;
    entities.player.name = blob.player?.name ?? entities.player.name;
    entities.player.color = blob.player?.color ?? entities.player.color;

    // Move player to saved position (if valid)
    const r = ROOMS[state.roomKey] ?? ROOMS.lounge;
    entities.player.x = clamp(blob.player?.x ?? r.spawn.x, 0, r.w-1);
    entities.player.y = clamp(blob.player?.y ?? r.spawn.y, 0, r.h-1);
    entities.player.sit = null;
    entities.player.path = [];
    entities.player.moving = false;
    entities.player.t = 0;

    loadRoom(state.roomKey);
  }

  function saveToLocal(){
    localStorage.setItem(SAVE_KEY, JSON.stringify(buildSaveBlob()));
    toast("Saved.", "good");
    beep(880,0.05,"triangle",0.02);
  }

  function loadFromLocal(){
    const raw = localStorage.getItem(SAVE_KEY);
    if(!raw){ toast("No save found.", "warn"); return; }
    try{
      const blob = JSON.parse(raw);
      applySaveBlob(blob);
      toast("Loaded.", "good");
      beep(660,0.06,"sine",0.02);
    }catch(e){
      toast("Load failed.", "bad");
      console.error(e);
    }
  }

  function exportSave(){
    const blob = buildSaveBlob();
    const text = JSON.stringify(blob, null, 2);
    navigator.clipboard?.writeText(text).then(()=>{
      toast("Save JSON copied to clipboard.", "good");
      beep(990,0.06,"square",0.02);
    }).catch(()=>{
      // fallback prompt
      prompt("Copy your save JSON:", text);
    });
  }

  function importSave(){
    const txt = prompt("Paste save JSON:");
    if(!txt) return;
    try{
      const blob = JSON.parse(txt);
      applySaveBlob(blob);
      toast("Imported.", "good");
      beep(740,0.06,"triangle",0.02);
    }catch(e){
      toast("Import failed.", "bad");
    }
  }

  /* -----------------------------
     Chat system
  ------------------------------*/
  function logChat(html, isSys=false){
    const div = document.createElement("div");
    div.innerHTML = html;
    if(isSys) div.classList.add("sys");
    chatlog.appendChild(div);
    chatlog.scrollTop = chatlog.scrollHeight;
  }

  function say(entity, text){
    const until = now() + 4200;
    entity.bubble = { text, until };
    // also push to global bubbles for rendering order
    runtime.bubbles.push({ id: makeId("b"), entId: entity.id, text, until });
  }

  function sys(msg){
    logChat(`<span class="sys">[${fmtTime()}] ${msg}</span>`, true);
  }

  function chat(name, msg){
    logChat(`<span class="muted">[${fmtTime()}]</span> <b>${escapeHtml(name)}:</b> ${escapeHtml(msg)}`);
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;");
  }

  /* -----------------------------
     Inventory
  ------------------------------*/
  const inventory = {
    // counts
    sofa: 1,
    plant: 1,
    rug: 1,
    lamp: 0,
    table: 0,
    poster: 0,
    arcade: 0
  };

  function addItem(key, n=1){
    inventory[key] = (inventory[key]||0) + n;
    renderInventory();
  }

  function removeItem(key, n=1){
    inventory[key] = (inventory[key]||0) - n;
    if(inventory[key] < 0) inventory[key] = 0;
    renderInventory();
  }

  function renderInventory(){
    invList.innerHTML = "";
    const keys = Object.keys(inventory).filter(k => (inventory[k]||0) > 0);
    if(keys.length === 0){
      const empty = document.createElement("div");
      empty.className="card tiny muted";
      empty.textContent="No items. Buy from shop.";
      invList.appendChild(empty);
      return;
    }
    for(const k of keys){
      const def = FURNI[k];
      const item = document.createElement("div");
      item.className = "item" + (state.selectedItemKey===k ? " active":"");
      item.innerHTML = `
        <div class="meta">
          <div class="name">${def.name}</div>
          <div class="desc">${def.desc}</div>
        </div>
        <div class="badge">x${inventory[k]}</div>
      `;
      item.onclick = () => {
        state.selectedItemKey = (state.selectedItemKey === k) ? null : k;
        runtime.placing = null;
        renderInventory();
        renderBuildButton();
        if(state.selectedItemKey){
          toast(`Selected: ${def.name}`, "good", 1400);
          beep(720,0.04,"sine",0.02);
        }else{
          toast("Selection cleared.", "warn", 1200);
          beep(420,0.04,"sine",0.02);
        }
      };
      invList.appendChild(item);
    }
  }

  function renderShop(){
    shopGrid.innerHTML = "";
    for(const k of SHOP){
      const def = FURNI[k];
      const box = document.createElement("div");
      box.className = "card";
      box.innerHTML = `
        <div class="row">
          <div style="display:flex;flex-direction:column;gap:2px;min-width:0">
            <div style="font-weight:800;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${def.name}</div>
            <div class="tiny muted" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${def.desc}</div>
          </div>
          <div class="tag">${def.price} px</div>
        </div>
        <div class="divider"></div>
        <button class="btn" style="width:100%" data-buy="${k}">Buy</button>
      `;
      box.querySelector("button").onclick = () => {
        if(state.pixels < def.price){
          toast("Not enough pixels.", "warn");
          beep(220,0.06,"sawtooth",0.02);
          return;
        }
        state.pixels -= def.price;
        addItem(k,1);
        toast(`Bought ${def.name}.`, "good");
        beep(920,0.05,"square",0.02);
        renderStats();
      };
      shopGrid.appendChild(box);
    }
  }

  /* -----------------------------
     Room loading & furniture
  ------------------------------*/
  function getRoomRuntimeKey(roomKey){
    return "room_" + roomKey;
  }

  function loadRoom(roomKey){
    const room = ROOMS[roomKey] ?? ROOMS.lounge;
    runtime.room = deepClone(room);

    // If we have saved custom furniture for this room, use it. Otherwise start from decor.
    if(!state.roomFurni[getRoomRuntimeKey(roomKey)]){
      state.roomFurni[getRoomRuntimeKey(roomKey)] = deepClone(room.decor || []);
    }
    runtime.furni = deepClone(state.roomFurni[getRoomRuntimeKey(roomKey)]);

    // Keep NPC positions sensible if room changes
    if(roomKey === "lounge"){
      entities.npcs[0].x=4; entities.npcs[0].y=3; entities.npcs[0].z=heightAt(4,3);
      entities.npcs[1].x=8; entities.npcs[1].y=7; entities.npcs[1].z=heightAt(8,7);
    }else if(roomKey === "courtyard"){
      entities.npcs[0].x=5; entities.npcs[0].y=2; entities.npcs[0].z=heightAt(5,2);
      entities.npcs[1].x=10; entities.npcs[1].y=6; entities.npcs[1].z=heightAt(10,6);
    }else{
      entities.npcs[0].x=3; entities.npcs[0].y=3; entities.npcs[0].z=heightAt(3,3);
      entities.npcs[1].x=11; entities.npcs[1].y=8; entities.npcs[1].z=heightAt(11,8);
    }

    // Clamp player into bounds
    entities.player.x = clamp(entities.player.x, 0, room.w-1);
    entities.player.y = clamp(entities.player.y, 0, room.h-1);
    entities.player.z = heightAt(entities.player.x, entities.player.y);
    entities.player.px = entities.player.x;
    entities.player.py = entities.player.y;
    entities.player.pz = entities.player.z;

    // Center camera
    centerCameraOn(entities.player.x, entities.player.y, true);

    renderRoomList();
    renderStats();
    renderQuestHUD();
  }

  function heightAt(x,y){
    const r = runtime.room;
    if(!r) return 0;
    return r.heights[idx(r.w,x,y)] ?? 0;
  }

  function isFloor(x,y){
    const r = runtime.room;
    if(!r) return false;
    if(x<0||y<0||x>=r.w||y>=r.h) return false;
    return !r.walls[idx(r.w,x,y)];
  }

  function furniAt(x,y){
    // return topmost furni at tile
    for(let i=runtime.furni.length-1;i>=0;i--){
      const f = runtime.furni[i];
      if(f.x===x && f.y===y) return f;
    }
    return null;
  }

  function blocksTile(x,y){
    const f = furniAt(x,y);
    if(!f) return false;
    const def = FURNI[f.type];
    return !!def.blocks;
  }

  function walkable(x,y, fromX=null, fromY=null){
    if(!isFloor(x,y)) return false;
    if(blocksTile(x,y)) return false;
    // height delta constraint
    if(fromX!==null && fromY!==null){
      const dz = Math.abs(heightAt(x,y) - heightAt(fromX,fromY));
      if(dz > MAX_STEP) return false;
    }
    return true;
  }

  /* -----------------------------
     Isometric projection
  ------------------------------*/
  function isoToScreen(x,y,z){
    const ox = canvas.width/2 + camera.x;
    const oy = canvas.height*0.22 + camera.y;
    const sx = (x - y) * (TILE_W/2);
    const sy = (x + y) * (TILE_H/2) - z*HEIGHT_UNIT;
    return { x: (ox + sx) * camera.zoom, y: (oy + sy) * camera.zoom };
  }

  function screenToIso(sx,sy){
    // Convert screen coords to approximate iso tile (ignoring z)
    const ox = canvas.width/2 + camera.x;
    const oy = canvas.height*0.22 + camera.y;
    const x0 = sx / camera.zoom - ox;
    const y0 = sy / camera.zoom - oy;

    const tx = x0 / (TILE_W/2);
    const ty = y0 / (TILE_H/2);

    const x = (tx + ty) / 2;
    const y = (ty - tx) / 2;

    return { x, y };
  }

  function centerCameraOn(x,y, instant=false){
    const p = isoToScreen(x,y,heightAt(x,y));
    const targetX = (canvas.width/2) - p.x;
    const targetY = (canvas.height*0.50) - p.y;
    if(instant){
      camera.x += targetX;
      camera.y += targetY;
    }else{
      camera.x = lerp(camera.x, camera.x + targetX, 0.15);
      camera.y = lerp(camera.y, camera.y + targetY, 0.15);
    }
  }

  /* -----------------------------
     A* Pathfinding on tile grid
  ------------------------------*/
  function findPath(sx,sy,gx,gy){
    const r = runtime.room;
    if(!r) return [];

    if(!walkable(gx,gy, sx,sy)) return [];

    const W = r.w, H = r.h;

    const start = {x:sx,y:sy};
    const goal = {x:gx,y:gy};

    const key = (x,y)=> x+","+y;
    const h = (x,y)=> Math.abs(x-goal.x)+Math.abs(y-goal.y);

    const open = new Map();
    const came = new Map();
    const gScore = new Map();

    const startK = key(start.x,start.y);
    open.set(startK, {x:start.x,y:start.y,f:h(start.x,start.y)});
    gScore.set(startK, 0);

    const dirs = [
      [1,0],[-1,0],[0,1],[0,-1]
    ];

    function lowestOpen(){
      let bestK=null, bestF=Infinity, best=null;
      for(const [k,n] of open){
        if(n.f < bestF){ bestF=n.f; bestK=k; best=n; }
      }
      return {k:bestK, n:best};
    }

    const closed = new Set();

    while(open.size){
      const {k:ck, n:cur} = lowestOpen();
      if(!cur) break;

      if(cur.x===goal.x && cur.y===goal.y){
        // reconstruct
        const path = [];
        let tk = ck;
        while(tk !== startK){
          const p = came.get(tk);
          if(!p) break;
          const [px,py] = tk.split(",").map(Number);
          path.push({x:px,y:py});
          tk = p;
        }
        path.reverse();
        return path;
      }

      open.delete(ck);
      closed.add(ck);

      for(const [dx,dy] of dirs){
        const nx = cur.x + dx, ny = cur.y + dy;
        if(nx<0||ny<0||nx>=W||ny>=H) continue;
        const nk = key(nx,ny);
        if(closed.has(nk)) continue;
        if(!walkable(nx,ny, cur.x,cur.y)) continue;

        const tentativeG = (gScore.get(ck) ?? Infinity) + 1 + (Math.abs(heightAt(nx,ny)-heightAt(cur.x,cur.y))*0.25);
        if(tentativeG < (gScore.get(nk) ?? Infinity)){
          came.set(nk, ck);
          gScore.set(nk, tentativeG);
          const f = tentativeG + h(nx,ny);
          open.set(nk, {x:nx,y:ny,f});
        }
      }
    }
    return [];
  }

  /* -----------------------------
     Build mode: placing furniture
  ------------------------------*/
  function canPlace(typeKey,x,y){
    if(!isFloor(x,y)) return false;
    if(furniAt(x,y)) return false;
    // don't place on player or NPC
    if(entities.player.x===x && entities.player.y===y) return false;
    for(const n of entities.npcs){
      if(n.x===x && n.y===y) return false;
    }
    // Posters as wall items: only allow along boundary-ish (simple rule)
    const def = FURNI[typeKey];
    if(def.wall){
      const r = runtime.room;
      const isEdge = (x===1 || y===1 || x===r.w-2 || y===r.h-2);
      if(!isEdge) return false;
    }
    return true;
  }

  function placeSelectedAt(x,y){
    const key = state.selectedItemKey;
    if(!key) return;
    if((inventory[key]||0) <= 0) return;

    if(!canPlace(key,x,y)){
      toast("Can't place there.", "warn");
      beep(260,0.06,"sawtooth",0.02);
      return;
    }
    const f = { id: makeId("f"), type:key, x,y, rot: state.rotate%4 };
    runtime.furni.push(f);
    state.roomFurni[getRoomRuntimeKey(state.roomKey)] = deepClone(runtime.furni);

    removeItem(key,1);
    state.steps += 0; // no change
    toast(`Placed ${FURNI[key].name}.`, "good");
    beep(860,0.05,"triangle",0.02);

    // achievement: placed 10
    const placedCount = runtime.furni.length;
    if(!state.ach.placed10 && placedCount >= 10){
      state.ach.placed10 = true;
      state.pixels += 40;
      toast("Achievement: Decorator (+40 px)", "good", 3000);
      sys("Achievement unlocked: Decorator (+40 px).");
      beep(1040,0.09,"square",0.03);
    }
    renderStats();
  }

  /* -----------------------------
     Interactions (sit, NPC talk)
  ------------------------------*/
  function tryInteractAt(x,y){
    // Furniture interaction first
    const f = furniAt(x,y);
    if(f){
      const def = FURNI[f.type];
      if(def.sit){
        // sit adjacent or on tile if you are there
        if(entities.player.x===x && entities.player.y===y){
          entities.player.sit = {x,y};
          entities.player.moving = false;
          entities.player.path = [];
          say(entities.player, "…");
          sys("You sit down.");
          beep(520,0.05,"sine",0.015);
          return true;
        }else{
          // walk there
          walkTo(x,y,true);
          sys("Walking to sit…");
          return true;
        }
      }
      if(f.type==="arcade"){
        // mini “arcade”
        const win = Math.random() < 0.28;
        if(win){
          state.pixels += 12;
          toast("Arcade: you won +12 px!", "good", 2200);
          sys("Arcade payout: +12 pixels.");
          beep(980,0.08,"square",0.03);
        }else{
          toast("Arcade: no win this time.", "warn", 1700);
          beep(220,0.06,"triangle",0.02);
        }
        renderStats();
        // quest stage trigger
        if(state.quest.active && state.quest.id==="coffee_run" && state.quest.stage===1){
          state.quest.stage = 2;
          renderQuestHUD();
          sys("Quest updated: Return to Bean.");
          say(entities.player, "Got it!");
        }
        return true;
      }
      if(f.type==="lamp"){
        // toggle lamp (store on instance)
        f.on = !f.on;
        toast(f.on ? "Lamp on." : "Lamp off.", "good", 1200);
        beep(680,0.04,"sine",0.02);
        state.roomFurni[getRoomRuntimeKey(state.roomKey)] = deepClone(runtime.furni);
        return true;
      }
      // default
      toast(`${def.name}: ${def.desc}`, "good", 1400);
      return true;
    }

    // NPC interactions
    for(const n of entities.npcs){
      if(n.x===x && n.y===y){
        onTalkNPC(n);
        return true;
      }
    }
    return false;
  }

  function onTalkNPC(npc){
    const q = state.quest;
    if(npc.id==="npc_bean"){
      if(q.active && q.id==="coffee_run" && !q.done){
        if(q.stage===0){
          q.stage = 1;
          sys("Quest started: Use the Arcade to fetch a coffee token, then return.");
          say(npc, "Hey! Can you grab a coffee token from the Arcade?");
          say(entities.player, "On it.");
          renderQuestHUD();
          beep(740,0.06,"triangle",0.02);
          return;
        }
        if(q.stage===2){
          q.done = true;
          q.active = false;
          state.pixels += 60;
          state.ach.questDone = true;
          sys("Quest complete: +60 pixels.");
          toast("Quest complete! +60 px", "good", 2600);
          say(npc, "Legend. Enjoy the pixels.");
          say(entities.player, "Cheers.");
          renderQuestHUD();
          renderStats();
          beep(1020,0.1,"square",0.03);
          return;
        }
        say(npc, "Still waiting on that token… try the Arcade.");
        return;
      }
      say(npc, "Fresh brews, quiet vibes.");
      return;
    }

    if(npc.id==="npc_ivy"){
      say(npc, "Try build mode. Make the room yours.");
      sys("Tip: Build Mode → select item → click tile to place. Rotate with R.");
      beep(660,0.05,"sine",0.015);
      return;
    }

    say(npc, "Hello.");
  }

  /* -----------------------------
     Movement
  ------------------------------*/
  function walkTo(tx,ty, allowInteract=false){
    const p = entities.player;
    if(!walkable(tx,ty, p.x,p.y)) {
      if(allowInteract) tryInteractAt(tx,ty);
      return;
    }
    p.sit = null;
    const path = findPath(p.x,p.y,tx,ty);
    if(path.length===0){
      if(allowInteract) tryInteractAt(tx,ty);
      return;
    }
    p.path = path;
    p.moving = true;
    p.t = 0;
    beep(520,0.02,"sine",0.01);
  }

  function stepPlayer(dt){
    const p = entities.player;
    if(!p.moving || p.path.length===0) return;

    const speed = 4.2; // tiles per second
    p.t += dt * speed;

    if(p.t >= 1){
      // complete a tile step
      const next = p.path.shift();
      if(!next){ p.moving=false; p.t=0; return; }

      // update direction for “feel”
      const dx = next.x - p.x;
      const dy = next.y - p.y;
      p.dir = (dx===1)?0:(dx===-1)?2:(dy===1)?1:3;

      p.x = next.x;
      p.y = next.y;
      p.z = heightAt(p.x,p.y);
      state.steps += 1;

      // achievements
      if(!state.ach.walked100 && state.steps >= 100){
        state.ach.walked100 = true;
        state.pixels += 50;
        toast("Achievement: Walker (+50 px)", "good", 3000);
        sys("Achievement unlocked: Walker (+50 px).");
        beep(1040,0.09,"square",0.03);
        renderStats();
      }

      // if we arrived
      if(p.path.length===0){
        p.moving = false;
        p.t = 0;
      }else{
        p.t -= 1;
      }
    }

    // interpolate render position
    const next = p.path[0];
    if(next){
      p.px = lerp(p.x, next.x, p.t);
      p.py = lerp(p.y, next.y, p.t);
      p.pz = lerp(p.z, heightAt(next.x,next.y), p.t);
    }else{
      p.px = lerp(p.px, p.x, 0.25);
      p.py = lerp(p.py, p.y, 0.25);
      p.pz = lerp(p.pz, p.z, 0.25);
    }
  }

  /* -----------------------------
     Rendering
  ------------------------------*/
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels coordinates

    // minimap is fixed size; just clear on update
  }
  window.addEventListener("resize", resize);

  function draw(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    // Clear
    ctx.clearRect(0,0,w,h);

    // day/night tint
    runtime.timeOfDay = (runtime.timeOfDay + 0.00055) % 1;
    const night = 0.5 + 0.5*Math.sin(runtime.timeOfDay * Math.PI*2);
    const vignette = 0.10 + 0.14*(1-night);

    // Background gradient
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, `rgba(255,255,255,${0.03 + 0.05*night})`);
    g.addColorStop(1, `rgba(0,0,0,${0.0})`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // Camera zoom easing
    camera.zoom = lerp(camera.zoom, camera.targetZoom, 0.12);

    // Draw room tiles back-to-front (by y then x)
    const r = runtime.room;
    if(!r) return;

    // Collect drawables: tiles + furni + entities
    const drawables = [];

    for(let y=0;y<r.h;y++){
      for(let x=0;x<r.w;x++){
        if(!isFloor(x,y)) continue;
        const z = heightAt(x,y);
        drawables.push({ kind:"tile", x,y,z, sort: (x+y)*10 + z });
      }
    }

    for(const f of runtime.furni){
      drawables.push({ kind:"furni", f, x:f.x,y:f.y,z:heightAt(f.x,f.y), sort:(f.x+f.y)*10 + heightAt(f.x,f.y)+1 });
    }

    // NPCs
    for(const n of entities.npcs){
      drawables.push({ kind:"npc", e:n, x:n.x,y:n.y,z:heightAt(n.x,n.y), sort:(n.x+n.y)*10 + heightAt(n.x,n.y)+2 });
    }

    // Player last
    const p = entities.player;
    drawables.push({ kind:"player", e:p, x:p.px,y:p.py,z:p.pz, sort:(p.px+p.py)*10 + p.pz+3 });

    drawables.sort((a,b)=> a.sort - b.sort);

    // soft shadows layer
    for(const d of drawables){
      if(d.kind==="player" || d.kind==="npc" || d.kind==="furni"){
        drawShadow(d);
      }
    }

    for(const d of drawables){
      if(d.kind==="tile") drawTile(d.x,d.y,d.z, night);
      else if(d.kind==="furni") drawFurni(d.f, night);
      else if(d.kind==="npc") drawAvatar(d.e, night, true);
      else if(d.kind==="player") drawAvatar(d.e, night, false);
    }

    // Placement preview
    if(state.buildMode && state.selectedItemKey && runtime.placing){
      drawPlacement(runtime.placing.x, runtime.placing.y, runtime.placing.ok);
    }

    // Speech bubbles
    drawBubbles();

    // Vignette
    ctx.fillStyle = `rgba(0,0,0,${vignette})`;
    ctx.fillRect(0,0,w,Math.min(140,h));
    ctx.fillRect(0,h-160,w,Math.min(160,h));
  }

  function drawTile(x,y,z, night){
    const p = isoToScreen(x,y,z);
    const cx = p.x, cy = p.y;

    const tw = TILE_W * camera.zoom;
    const th = TILE_H * camera.zoom;

    // Color based on height
    const base = 36 + z*10;
    const c1 = `rgba(${base},${base},${base+6},${0.92})`;
    const c2 = `rgba(${base-10},${base-10},${base-4},${0.92})`;

    // Diamond
    ctx.beginPath();
    ctx.moveTo(cx, cy - th/2);
    ctx.lineTo(cx + tw/2, cy);
    ctx.lineTo(cx, cy + th/2);
    ctx.lineTo(cx - tw/2, cy);
    ctx.closePath();

    // Fill with subtle gradient illusion
    ctx.fillStyle = c1;
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 1;
    ctx.stroke();

    // Side face if raised
    if(z>0){
      // right face
      ctx.beginPath();
      ctx.moveTo(cx + tw/2, cy);
      ctx.lineTo(cx + tw/2, cy + z*HEIGHT_UNIT*camera.zoom);
      ctx.lineTo(cx, cy + th/2 + z*HEIGHT_UNIT*camera.zoom);
      ctx.lineTo(cx, cy + th/2);
      ctx.closePath();
      ctx.fillStyle = c2;
      ctx.fill();

      // left face
      ctx.beginPath();
      ctx.moveTo(cx - tw/2, cy);
      ctx.lineTo(cx - tw/2, cy + z*HEIGHT_UNIT*camera.zoom);
      ctx.lineTo(cx, cy + th/2 + z*HEIGHT_UNIT*camera.zoom);
      ctx.lineTo(cx, cy + th/2);
      ctx.closePath();
      ctx.fillStyle = `rgba(${base-16},${base-16},${base-12},0.92)`;
      ctx.fill();
    }

    // Night tint
    if(night < 0.35){
      ctx.fillStyle = `rgba(0,0,0,${(0.35-night)*0.35})`;
      ctx.fill();
    }
  }

  function drawShadow(d){
    let x=d.x, y=d.y, z=d.z;
    // Use iso center for entity
    const p = isoToScreen(x,y, heightAt(Math.round(x),Math.round(y)));
    const cx=p.x, cy=p.y + (TILE_H*0.10)*camera.zoom + (heightAt(Math.round(x),Math.round(y))*HEIGHT_UNIT*camera.zoom);

    ctx.beginPath();
    const rx = 12*camera.zoom;
    const ry = 6*camera.zoom;
    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fill();
  }

  function drawFurni(f, night){
    const def = FURNI[f.type];
    const z = heightAt(f.x,f.y);
    const p = isoToScreen(f.x,f.y,z);
    const cx=p.x, cy=p.y;

    const tw = TILE_W*camera.zoom;
    const th = TILE_H*camera.zoom;

    // Rug: flat
    if(f.type==="rug"){
      ctx.beginPath();
      ctx.moveTo(cx, cy - th/2);
      ctx.lineTo(cx + tw/2, cy);
      ctx.lineTo(cx, cy + th/2);
      ctx.lineTo(cx - tw/2, cy);
      ctx.closePath();
      ctx.fillStyle = "rgba(203,185,255,0.26)";
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.stroke();
      return;
    }

    // Poster: draw a “wall-ish” placard
    if(def.wall){
      const o = isoToScreen(f.x,f.y,z);
      ctx.save();
      ctx.translate(o.x, o.y - th/2 - 18*camera.zoom);
      ctx.rotate((f.rot%4===1 ? 0.12 : f.rot%4===3 ? -0.12 : 0));
      ctx.fillStyle = "rgba(155,188,255,0.22)";
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 1;
      const ww = 26*camera.zoom, hh = 18*camera.zoom;
      ctx.beginPath();
      ctx.roundRect(-ww/2, -hh/2, ww, hh, 6*camera.zoom);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      return;
    }

    // Lamp light
    const lampOn = (f.type==="lamp" && f.on);

    // Simple block furniture
    const height = (f.type==="sofa") ? 14 : (f.type==="arcade") ? 24 : (f.type==="plant") ? 22 : 18;
    const hpx = height*camera.zoom;

    // top diamond
    const topY = cy - hpx;
    ctx.beginPath();
    ctx.moveTo(cx, topY - th/2);
    ctx.lineTo(cx + tw/2, topY);
    ctx.lineTo(cx, topY + th/2);
    ctx.lineTo(cx - tw/2, topY);
    ctx.closePath();
    ctx.fillStyle = hexToRgba(def.color, 0.92);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.stroke();

    // right face
    ctx.beginPath();
    ctx.moveTo(cx + tw/2, topY);
    ctx.lineTo(cx + tw/2, cy);
    ctx.lineTo(cx, cy + th/2);
    ctx.lineTo(cx, topY + th/2);
    ctx.closePath();
    ctx.fillStyle = hexToRgba(shade(def.color, -18), 0.88);
    ctx.fill();

    // left face
    ctx.beginPath();
    ctx.moveTo(cx - tw/2, topY);
    ctx.lineTo(cx - tw/2, cy);
    ctx.lineTo(cx, cy + th/2);
    ctx.lineTo(cx, topY + th/2);
    ctx.closePath();
    ctx.fillStyle = hexToRgba(shade(def.color, -30), 0.88);
    ctx.fill();

    // Sofa detail
    if(f.type==="sofa"){
      ctx.fillStyle = "rgba(0,0,0,0.14)";
      ctx.fillRect(cx - 12*camera.zoom, topY - 2*camera.zoom, 24*camera.zoom, 4*camera.zoom);
    }

    // Plant detail
    if(f.type==="plant"){
      ctx.beginPath();
      ctx.arc(cx, topY - 6*camera.zoom, 9*camera.zoom, 0, Math.PI*2);
      ctx.fillStyle = "rgba(159,226,177,0.45)";
      ctx.fill();
    }

    // Arcade detail
    if(f.type==="arcade"){
      ctx.fillStyle = "rgba(0,0,0,0.20)";
      ctx.fillRect(cx - 10*camera.zoom, topY - 4*camera.zoom, 20*camera.zoom, 6*camera.zoom);
      ctx.fillStyle = "rgba(255,255,255,0.18)";
      ctx.fillRect(cx - 6*camera.zoom, topY + 2*camera.zoom, 12*camera.zoom, 2*camera.zoom);
    }

    // Lamp glow
    if(lampOn){
      const glow = ctx.createRadialGradient(cx, topY - 10*camera.zoom, 4*camera.zoom, cx, topY - 10*camera.zoom, 80*camera.zoom);
      glow.addColorStop(0, "rgba(255,210,138,0.32)");
      glow.addColorStop(1, "rgba(255,210,138,0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(cx, topY - 10*camera.zoom, 80*camera.zoom, 0, Math.PI*2);
      ctx.fill();
    }

    // Night dim
    if(night < 0.35 && !lampOn){
      ctx.fillStyle = `rgba(0,0,0,${(0.35-night)*0.28})`;
      ctx.fill();
    }
  }

  function drawAvatar(e, night, npc=false){
    const z = heightAt(Math.round(e.x),Math.round(e.y));
    const p = isoToScreen(e.px ?? e.x, e.py ?? e.y, e.pz ?? z);
    const cx=p.x, cy=p.y;

    const bob = (e.moving ? Math.sin((performance.now()/85)) * 1.5 : 0) * camera.zoom;
    const sit = (!npc && entities.player.sit) ? 6*camera.zoom : 0;

    // body
    const bodyY = cy - 26*camera.zoom + bob + sit;
    const headY = bodyY - 14*camera.zoom;

    // shadow outline
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 3*camera.zoom;

    // torso
    ctx.beginPath();
    ctx.roundRect(cx - 8*camera.zoom, bodyY, 16*camera.zoom, 18*camera.zoom, 6*camera.zoom);
    ctx.fillStyle = hexToRgba(e.color || "#ffffff", npc ? 0.70 : 0.88);
    ctx.fill();
    ctx.stroke();

    // head
    ctx.beginPath();
    ctx.arc(cx, headY, 8*camera.zoom, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fill();
    ctx.stroke();

    // face (simple)
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(cx - 4*camera.zoom, headY - 2*camera.zoom, 2*camera.zoom, 2*camera.zoom);
    ctx.fillRect(cx + 2*camera.zoom, headY - 2*camera.zoom, 2*camera.zoom, 2*camera.zoom);

    // nameplate
    ctx.font = `${12*camera.zoom}px ui-sans-serif, system-ui`;
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillStyle = npc ? "rgba(255,255,255,0.65)" : "rgba(255,255,255,0.85)";
    ctx.fillText(e.name, cx, headY - 10*camera.zoom);

    // emote
    if(!npc && e.emote && now() < e.emoteUntil){
      ctx.font = `${14*camera.zoom}px ui-sans-serif, system-ui`;
      ctx.fillStyle = "rgba(255,255,255,0.82)";
      ctx.fillText(e.emote, cx, headY - 28*camera.zoom);
    }

    // Night dim
    if(night < 0.35){
      ctx.fillStyle = `rgba(0,0,0,${(0.35-night)*0.22})`;
      ctx.beginPath();
      ctx.arc(cx, headY, 10*camera.zoom, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawPlacement(x,y, ok){
    const z = heightAt(x,y);
    const p = isoToScreen(x,y,z);
    const cx=p.x, cy=p.y;
    const tw = TILE_W*camera.zoom;
    const th = TILE_H*camera.zoom;

    ctx.beginPath();
    ctx.moveTo(cx, cy - th/2);
    ctx.lineTo(cx + tw/2, cy);
    ctx.lineTo(cx, cy + th/2);
    ctx.lineTo(cx - tw/2, cy);
    ctx.closePath();

    ctx.fillStyle = ok ? "rgba(126,240,179,0.20)" : "rgba(255,107,107,0.20)";
    ctx.fill();
    ctx.strokeStyle = ok ? "rgba(126,240,179,0.55)" : "rgba(255,107,107,0.55)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawBubbles(){
    // Remove expired
    runtime.bubbles = runtime.bubbles.filter(b => now() < b.until);

    // draw for entities that still have bubble
    const all = [entities.player, ...entities.npcs];
    for(const ent of all){
      if(!ent.bubble || now() > ent.bubble.until) continue;
      const z = heightAt(Math.round(ent.x),Math.round(ent.y));
      const p = isoToScreen(ent.px ?? ent.x, ent.py ?? ent.y, ent.pz ?? z);
      const cx=p.x, cy=p.y;

      const text = ent.bubble.text;
      ctx.font = `${12*camera.zoom}px ui-sans-serif, system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const padX = 10*camera.zoom, padY = 6*camera.zoom;
      const metrics = ctx.measureText(text);
      const bw = (metrics.width + padX*2);
      const bh = (18*camera.zoom + padY*2);

      const bx = cx - bw/2;
      const by = cy - 78*camera.zoom;

      ctx.fillStyle = "rgba(16,16,18,0.88)";
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;

      ctx.beginPath();
      roundRectPath(ctx, bx, by, bw, bh, 10*camera.zoom);
      ctx.fill();
      ctx.stroke();

      // tail
      ctx.beginPath();
      ctx.moveTo(cx, by+bh);
      ctx.lineTo(cx-7*camera.zoom, by+bh+10*camera.zoom);
      ctx.lineTo(cx+7*camera.zoom, by+bh+10*camera.zoom);
      ctx.closePath();
      ctx.fillStyle = "rgba(16,16,18,0.88)";
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.88)";
      ctx.fillText(text, cx, by+bh/2);
    }
  }

  function roundRectPath(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function hexToRgba(hex, a=1){
    const c = hex.replace("#","");
    const n = parseInt(c,16);
    const r = (n>>16)&255;
    const g = (n>>8)&255;
    const b = (n)&255;
    return `rgba(${r},${g},${b},${a})`;
  }

  function shade(hex, amt){
    const c = hex.replace("#","");
    const n = parseInt(c,16);
    let r = (n>>16)&255;
    let g = (n>>8)&255;
    let b = (n)&255;
    r = clamp(r+amt,0,255);
    g = clamp(g+amt,0,255);
    b = clamp(b+amt,0,255);
    return "#" + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
  }

  /* -----------------------------
     Minimap
  ------------------------------*/
  function drawMinimap(){
    const r = runtime.room;
    if(!r) return;
    const W = mini.width, H = mini.height;
    mctx.clearRect(0,0,W,H);

    const pad = 10;
    const cell = Math.min((W-2*pad)/r.w, (H-2*pad)/r.h);

    // floor
    for(let y=0;y<r.h;y++){
      for(let x=0;x<r.w;x++){
        if(!isFloor(x,y)) continue;
        const z = heightAt(x,y);
        const v = 26 + z*20;
        mctx.fillStyle = `rgba(${v},${v},${v+8},0.9)`;
        mctx.fillRect(pad + x*cell, pad + y*cell, cell-1, cell-1);
      }
    }

    // furni
    for(const f of runtime.furni){
      mctx.fillStyle = "rgba(255,255,255,0.15)";
      mctx.fillRect(pad + f.x*cell, pad + f.y*cell, cell-1, cell-1);
    }

    // npcs
    for(const n of entities.npcs){
      mctx.fillStyle = "rgba(255,207,102,0.65)";
      mctx.fillRect(pad + n.x*cell, pad + n.y*cell, cell-1, cell-1);
    }

    // player
    mctx.fillStyle = "rgba(255,255,255,0.9)";
    mctx.fillRect(pad + entities.player.x*cell, pad + entities.player.y*cell, cell-1, cell-1);

    // border
    mctx.strokeStyle = "rgba(255,255,255,0.10)";
    mctx.strokeRect(pad-1, pad-1, r.w*cell+1, r.h*cell+1);
  }

  /* -----------------------------
     UI Rendering
  ------------------------------*/
  function renderStats(){
    statName.textContent = entities.player.name;
    statPixels.textContent = state.pixels.toString();
    statSteps.textContent = state.steps.toString();
    statRoom.textContent = ROOMS[state.roomKey]?.name ?? state.roomKey;

    const achList = [];
    if(state.ach.firstChat) achList.push("Chatter");
    if(state.ach.walked100) achList.push("Walker");
    if(state.ach.placed10) achList.push("Decorator");
    if(state.ach.questDone) achList.push("Helper");
    statAch.textContent = achList.length ? achList.join(", ") : "—";

    statusPill.textContent = `Pixels: ${state.pixels} • Build: ${state.buildMode ? "On":"Off"} • Zoom: ${camera.zoom.toFixed(2)}`;
  }

  function renderQuestHUD(){
    const q = state.quest;
    if(q.active && q.id==="coffee_run" && !q.done){
      if(q.stage===0) hudQuest.textContent = "Quest: Talk to Bean (NPC)";
      if(q.stage===1) hudQuest.textContent = "Quest: Use the Arcade";
      if(q.stage===2) hudQuest.textContent = "Quest: Return to Bean";
    }else{
      hudQuest.textContent = "Quest: Completed";
    }
  }

  function renderBuildButton(){
    btnBuild.textContent = `Build: ${state.buildMode ? "On" : "Off"}`;
    btnBuild.classList.toggle("primary", state.buildMode);
  }

  function renderRoomList(){
    roomList.innerHTML = "";
    for(const key of Object.keys(ROOMS)){
      const r = ROOMS[key];
      const div = document.createElement("div");
      div.className = "item" + (state.roomKey===key ? " active":"");
      div.innerHTML = `
        <div class="meta">
          <div class="name">${r.name}</div>
          <div class="desc">${r.w}×${r.h} • heights • decor</div>
        </div>
        <div class="badge">Go</div>
      `;
      div.onclick = () => {
        if(state.roomKey===key) return;
        state.roomKey = key;
        // move player to spawn
        entities.player.x = ROOMS[key].spawn.x;
        entities.player.y = ROOMS[key].spawn.y;
        entities.player.sit = null;
        entities.player.path = [];
        entities.player.moving = false;
        loadRoom(key);
        sys(`You entered: ${r.name}.`);
        toast(`Entered ${r.name}`, "good", 1600);
        beep(880,0.05,"triangle",0.02);
      };
      roomList.appendChild(div);
    }
  }

  /* -----------------------------
     Input
  ------------------------------*/
  const keysDown = new Set();

  window.addEventListener("keydown", (e)=>{
    if(e.key==="Escape"){
      runtime.placing = null;
      state.selectedItemKey = null;
      entities.player.sit = null;
      renderInventory();
      toast("Cancelled.", "warn", 1200);
      return;
    }
    keysDown.add(e.key.toLowerCase());

    if(e.key.toLowerCase()==="r"){
      state.rotate = (state.rotate + 1) % 4;
      toast(`Rotate: ${state.rotate}`, "good", 900);
      beep(660,0.03,"sine",0.02);
    }
  });
  window.addEventListener("keyup", (e)=> keysDown.delete(e.key.toLowerCase()));

  canvas.addEventListener("mousemove", (e)=>{
    if(!state.buildMode || !state.selectedItemKey) return;
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left);
    const sy = (e.clientY - rect.top);
    const iso = screenToIso(sx,sy);
    const tx = Math.round(iso.x);
    const ty = Math.round(iso.y);
    if(!runtime.room) return;
    if(tx<0||ty<0||tx>=runtime.room.w||ty>=runtime.room.h) return;
    runtime.placing = { typeKey: state.selectedItemKey, x:tx, y:ty, ok: canPlace(state.selectedItemKey, tx, ty) };
  });

  canvas.addEventListener("click", (e)=>{
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left);
    const sy = (e.clientY - rect.top);

    const iso = screenToIso(sx,sy);
    const tx = Math.round(iso.x);
    const ty = Math.round(iso.y);

    if(!runtime.room) return;
    if(tx<0||ty<0||tx>=runtime.room.w||ty>=runtime.room.h) return;

    // Build mode placement
    if(state.buildMode && state.selectedItemKey){
      placeSelectedAt(tx,ty);
      return;
    }

    // Interact if clicking on furni/NPC tile (or walk)
    if(tryInteractAt(tx,ty)) return;

    // Walk
    walkTo(tx,ty,false);
  });

  canvas.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    camera.targetZoom = clamp(camera.targetZoom + (-delta)*0.08, 0.70, 1.45);
    renderStats();
  }, { passive:false });

  btnBuild.onclick = () => {
    state.buildMode = !state.buildMode;
    runtime.placing = null;
    renderBuildButton();
    renderStats();
    toast(state.buildMode ? "Build mode on." : "Build mode off.", "good", 1500);
    beep(state.buildMode ? 860 : 420, 0.05, "sine", 0.02);
  };

  btnSave.onclick = saveToLocal;
  btnLoad.onclick = loadFromLocal;
  btnExport.onclick = exportSave;
  btnImport.onclick = importSave;

  btnHelp.onclick = () => {
    sys("Commands: /help /dance /wave /sit /stand /quest /buy <item> /place <item> /name <newname>");
    sys("Tips: Click to walk. Build mode places selected item. R rotates placement. WASD pans. Wheel zooms.");
    toast("Help printed to chat.", "good", 1600);
  };

  btnSound.onclick = () => {
    soundOn = !soundOn;
    btnSound.textContent = `Sound: ${soundOn ? "On" : "Off"}`;
    toast(`Sound ${soundOn ? "on" : "off"}.`, "good", 1200);
    if(soundOn) beep(880,0.05,"triangle",0.02);
  };

  btnSend.onclick = () => sendChat();
  chatInput.addEventListener("keydown", (e)=>{
    if(e.key==="Enter") sendChat();
  });

  function sendChat(){
    const raw = chatInput.value.trim();
    if(!raw) return;
    chatInput.value = "";

    // command?
    if(raw.startsWith("/")){
      runCommand(raw.slice(1));
      return;
    }

    // normal chat
    chat(entities.player.name, raw);
    say(entities.player, raw.length>28 ? raw.slice(0,28)+"…" : raw);

    if(!state.ach.firstChat){
      state.ach.firstChat = true;
      state.pixels += 15;
      toast("Achievement: Chatter (+15 px)", "good", 2600);
      sys("Achievement unlocked: Chatter (+15 px).");
      beep(1040,0.08,"square",0.03);
      renderStats();
    }
  }

  function runCommand(cmdLine){
    const parts = cmdLine.split(" ").filter(Boolean);
    const cmd = (parts.shift()||"").toLowerCase();
    const arg = parts.join(" ");

    switch(cmd){
      case "help":
        btnHelp.click();
        break;
      case "dance":
        entities.player.emote = "✦";
        entities.player.emoteUntil = now() + 4000;
        sys("You dance.");
        beep(920,0.05,"square",0.02);
        break;
      case "wave":
        entities.player.emote = "⟡";
        entities.player.emoteUntil = now() + 2500;
        sys("You wave.");
        beep(740,0.05,"triangle",0.02);
        break;
      case "sit":
        // sit if on sofa else sit anyway
        entities.player.sit = {x:entities.player.x,y:entities.player.y};
        sys("You sit.");
        beep(520,0.05,"sine",0.015);
        break;
      case "stand":
        entities.player.sit = null;
        sys("You stand.");
        beep(620,0.04,"sine",0.015);
        break;
      case "quest":
        if(state.quest.active && !state.quest.done){
          sys(`Quest: Coffee Run • stage ${state.quest.stage} (0=talk,1=arcade,2=return)`);
        }else{
          sys("Quest: Completed. (You can add more quests in code!)");
        }
        break;
      case "buy": {
        const key = (arg||"").toLowerCase();
        if(!FURNI[key]){ sys("Unknown item. Try: /buy sofa /buy plant /buy lamp /buy arcade"); break; }
        const def = FURNI[key];
        if(state.pixels < def.price){
          sys("Not enough pixels.");
          toast("Not enough pixels.", "warn");
          break;
        }
        state.pixels -= def.price;
        addItem(key,1);
        sys(`Bought ${def.name} for ${def.price} px.`);
        toast(`Bought ${def.name}.`, "good");
        beep(920,0.05,"square",0.02);
        renderStats();
        break;
      }
      case "place": {
        const key = (arg||"").toLowerCase();
        if(!FURNI[key]){ sys("Unknown item."); break; }
        if((inventory[key]||0)<=0){ sys("You don't have that item."); break; }
        state.selectedItemKey = key;
        state.buildMode = true;
        runtime.placing = null;
        renderInventory();
        renderBuildButton();
        renderStats();
        sys(`Build mode on. Selected ${FURNI[key].name}. Click a tile to place.`);
        toast("Build mode on.", "good");
        beep(860,0.05,"triangle",0.02);
        break;
      }
      case "name": {
        if(!arg){ sys("Usage: /name YourName"); break; }
        entities.player.name = arg.slice(0,18);
        sys(`Name set to ${entities.player.name}.`);
        renderStats();
        break;
      }
      default:
        sys("Unknown command. Try /help.");
    }
  }

  /* -----------------------------
     Game loop
  ------------------------------*/
  function tick(){
    const t = now();
    const dt = Math.min(0.033, (t - runtime.lastTick) / 1000);
    runtime.lastTick = t;
    runtime.fps = lerp(runtime.fps, (1/dt), 0.08);

    // WASD pan
    const pan = camera.panSpeed * dt;
    if(keysDown.has("a")) camera.x += pan;
    if(keysDown.has("d")) camera.x -= pan;
    if(keysDown.has("w")) camera.y += pan;
    if(keysDown.has("s")) camera.y -= pan;

    // Player movement
    stepPlayer(dt);

    // Keep player z synced when not moving
    if(!entities.player.moving){
      entities.player.z = heightAt(entities.player.x, entities.player.y);
      entities.player.px = lerp(entities.player.px, entities.player.x, 0.22);
      entities.player.py = lerp(entities.player.py, entities.player.y, 0.22);
      entities.player.pz = lerp(entities.player.pz, entities.player.z, 0.22);
    }

    // Update placement preview if hovering
    if(state.buildMode && state.selectedItemKey && runtime.placing){
      runtime.placing.ok = canPlace(state.selectedItemKey, runtime.placing.x, runtime.placing.y);
    }

    // If player reached a sit-target sofa tile, auto sit
    if(!entities.player.moving && !entities.player.sit){
      const f = furniAt(entities.player.x, entities.player.y);
      if(f && FURNI[f.type]?.sit){
        entities.player.sit = {x:f.x,y:f.y};
      }
    }

    // Update minimap occasionally
    if(Math.random() < 0.12) drawMinimap();

    // Render
    draw();

    // UI
    renderStats();

    // Status pill
    statusPill.textContent = `Pixels: ${state.pixels} • Build: ${state.buildMode ? "On":"Off"} • FPS: ${runtime.fps.toFixed(0)}`;

    requestAnimationFrame(tick);
  }

  /* -----------------------------
     Boot
  ------------------------------*/
  function boot(){
    resize();

    // Init player name nicer
    entities.player.name = entities.player.name || "Guest";

    // Load room
    loadRoom(state.roomKey);

    // Render UI
    renderShop();
    renderInventory();
    renderBuildButton();
    renderStats();
    drawMinimap();

    // Welcome chat
    sys("Welcome to IsoSocial.");
    sys("Click tiles to walk. Talk to NPCs by clicking them. Build Mode to place furniture.");
    sys("Try: /help");
    toast("Welcome. Talk to Bean for a quest.", "good", 2500);

    // Seed quest HUD
    renderQuestHUD();

    // Start loop
    requestAnimationFrame(tick);
  }

  boot();

})();
</script>
</body>
</html>


