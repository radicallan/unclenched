<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Spirit Board — Planchette (Trackpad)</title>
<style>
  :root{
    --bg:#0b0d12;--panel:#0f121a;--ink:#e7ebf2;--muted:#9aa3b2;--accent:#7ae1ff;--good:#7bf59a;--warn:#ffd166;--bad:#ff6b6b;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica Neue,Arial;background:var(--bg);color:var(--ink)}
  .wrap{display:grid;grid-template-columns:1fr 360px;gap:14px;height:100%;padding:14px}
  .stage{position:relative;border-radius:16px;background:radial-gradient(1200px 800px at 65% 35%,#0f141f,#090c12 55%);overflow:hidden}
  .side{display:flex;flex-direction:column;gap:12px}
  .card{background:var(--panel);border:1px solid #1b2330;border-radius:14px;padding:12px 14px}
  h1{font-size:16px;margin:0 0 4px 0}
  h2{font-size:15px;margin:0 0 6px 0}
  p{margin:6px 0;color:var(--muted)}
  button{appearance:none;border:1px solid #253146;background:#0f1622;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
  button.primary{background:linear-gradient(180deg,#162338,#0e1727);border-color:#253a5b}
  button.good{background:#0f1f15;border-color:#1f3a27;color:var(--good)}
  button.warn{background:#1d1608;border-color:#3c2f14;color:var(--warn)}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;padding:2px 6px;border:1px solid #2a3140;border-bottom-width:2px;border-radius:6px;background:#0b1018;color:#b9c1d0}
  canvas{position:absolute;inset:0;display:block;width:100%;height:100%;}
  /* Ensure pointer events hit the input layer (board) not the FX overlay */
  #fx{pointer-events:none}
  #board{pointer-events:auto}
  .hud{position:absolute;left:12px;top:12px;display:flex;gap:8px;align-items:center;z-index:10}
  .chip{background:#0e1420;border:1px solid #1e2a3f;color:#a9b3c6;padding:6px 10px;border-radius:999px}
  .chip strong{color:var(--ink)}
  .toast{position:absolute;left:50%;top:18px;transform:translateX(-50%);background:#0c1118;border:1px solid #1b2433;padding:10px 14px;border-radius:12px;color:var(--ink);opacity:0;pointer-events:none;transition:.3s ease;z-index:12}
  .toast.show{opacity:1;top:26px}
  .transcript{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0a0f16;border:1px solid #1b2330;border-radius:10px;padding:10px;max-height:180px;overflow:auto;white-space:pre-wrap}
  .badge{border:1px solid #2a2f3c;background:#11141c;padding:4px 8px;border-radius:8px;color:#b8bfcc}
  .switch{display:inline-flex;align-items:center;gap:8px}
  .switch input{accent-color:#2de2ff}
  footer{color:#7e8798;text-align:center}
</style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <div class="hud">
        <span class="chip">Mode: <strong id="hudMode">Idle</strong></span>
        <span class="chip">Layout: <strong id="hudLayout">Classic</strong></span>
        <span class="chip">Blind: <strong id="hudBlind">Off</strong></span>
        <span class="chip">Confidence: <strong id="hudConf">—</strong></span>
      </div>
      <div id="toast" class="toast">—</div>
      <canvas id="board"></canvas>
      <canvas id="fx"></canvas>
    </div>

    <div class="side">
      <div class="card">
        <h1>Spirit Board — Trackpad Planchette</h1>
        <p>Place one finger lightly on your trackpad and let the planchette follow. Don’t steer — just keep light contact. The board captures **ideomotor** micro‑movements and resolves answers by dwell.</p>
        <div class="row" style="margin-top:6px">
          <span class="kbd">Space</span> start/stop &nbsp; <span class="kbd">Esc</span> reset &nbsp; <span class="kbd">B</span> toggle blind &nbsp; <span class="kbd">S</span> shuffle
        </div>
      </div>

      <div class="card">
        <h2>Session</h2>
        <div class="row">
          <button class="primary" id="btnStart">Invite</button>
          <button id="btnStop">Goodbye</button>
          <button id="btnReset">Reset</button>
        </div>
        <p class="row" style="margin-top:8px">
          <label class="switch"><input type="checkbox" id="chkBlind"> Blind mode</label>
          <label class="switch"><input type="checkbox" id="chkShuffle"> Shuffle letters</label>
          <label class="switch"><input type="checkbox" id="chkSeal"> Seal transcript</label>
        </p>
        <div class="row">
          <button id="btnExport">Export JSON</button>
          <span class="badge" id="badgeLen">0 chars</span>
        </div>
      </div>

      <div class="card">
        <h2>Transcript</h2>
        <div class="transcript" id="log">(nothing yet)</div>
      </div>

      <div class="card">
        <h2>How it works (experiment)</h2>
        <p>• The planchette follows your pointer with slight smoothing and noise. <br/>• When its window dwells over a tile, that symbol is recorded. <br/>• In <em>Blind</em> mode the board hides symbols or shuffles them; you only see the text after you stop — a better test of ideomotor effects.</p>
      </div>

      <footer>Private, client‑side. No data leaves your browser.</footer>
    </div>
  </div>

<script>
(function(){
  // ======== Utilities ========
  const $=s=>document.querySelector(s);
  const toast=(t,d=1400)=>{const el=$('#toast');el.textContent=t;el.classList.add('show');setTimeout(()=>el.classList.remove('show'),d)};
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a,b)=>Math.random()*(b-a)+a;
  const hash32 = (s)=>{let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0};

  // ======== Canvas & Layout ========
  const board = document.getElementById('board');
  const fx = document.getElementById('fx');
  const ctx = board.getContext('2d');
  const gfx = fx.getContext('2d');
  // Helper to centre planchette/target on the board
  function centerPlanchette(){
    const r = board.getBoundingClientRect();
    const cx = (r.width * 0.52) * DPR;
    const cy = (r.height * 0.58) * DPR;
    target.x = cx; target.y = cy;
    plan.x = cx; plan.y = cy;
  }
  const DPR = Math.min(2, window.devicePixelRatio||1);
  function resize(){
    const r = board.parentElement.getBoundingClientRect();
    [board,fx].forEach(c=>{ c.width = r.width*DPR; c.height=r.height*DPR; c.style.width=r.width+'px'; c.style.height=r.height+'px';});
    drawBoard();
    // Keep the planchette centred when not actively running
    if(!state.running){ centerPlanchette(); drawFX(0); }
  }
  window.addEventListener('resize', resize);

  // ======== Board Model ========
  const symbolsClassic = {
    ring1:[...'ABCDEFGH'],
    ring2:[...'IJKLMNOP'],
    ring3:[...'QRSTUVWXYZ'],
    numbers:[...'1234567890'],
    corners:['YES','NO','GOODBYE']
  };
  let layoutShuffle=false, blind=false;
  let layout = JSON.parse(JSON.stringify(symbolsClassic));
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]] } }
  function makeLayout(){
    layout = JSON.parse(JSON.stringify(symbolsClassic));
    if(layoutShuffle){ shuffle(layout.ring1); shuffle(layout.ring2); shuffle(layout.ring3); shuffle(layout.numbers); }
    $('#hudLayout').textContent = layoutShuffle? 'Shuffled' : 'Classic';
    $('#hudBlind').textContent = blind? 'On':'Off';
  }

  // Ring geometry cache
  const tiles=[]; // {x,y,r,label}

  function drawBoard(){
    ctx.clearRect(0,0,board.width, board.height);
    const W=board.width, H=board.height;
    // background halo
    const grad = ctx.createRadialGradient(W*0.62,H*0.35,10, W*0.62,H*0.35, Math.max(W,H)*0.9);
    grad.addColorStop(0,'rgba(255,255,255,0.05)'); grad.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=grad; ctx.fillRect(0,0,W,H);

    tiles.length=0;
    const cx=W*0.52, cy=H*0.58; // board center
    const baseR = Math.min(W,H)*0.36;

    const drawRing=(chars,r,visible=true)=>{
      const n = chars.length; const a0=-Math.PI*0.8, a1=-Math.PI*0.2;
      for(let i=0;i<n;i++){
        const t = i/(n-1); const ang= a0 + (a1-a0)*t;
        const x = cx + Math.cos(ang)*r, y = cy + Math.sin(ang)*r;
        tiles.push({x,y,r:Math.min(W,H)*0.03,label:chars[i],type:'char'});
        if(visible && !blind){ ctx.fillStyle='#cfd6e6'; ctx.font=(Math.min(W,H)*0.035)+'px ui-monospace,Menlo,Consolas'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(chars[i],x,y); }
      }
    }

    drawRing(layout.ring1, baseR*0.70, true);
    drawRing(layout.ring2, baseR*0.86, true);
    drawRing(layout.ring3, baseR*1.02, true);

    // Numbers along bottom
    const nb = layout.numbers; const nbY = cy + baseR*0.55; const nbW = Math.min(W,H)*0.03;
    for(let i=0;i<nb.length;i++){
      const x = (W*0.20) + i*(W*0.6/ (nb.length-1));
      tiles.push({x,y:nbY,r:nbW,label:nb[i],type:'num'});
      if(!blind){ ctx.fillStyle='#aab3c7'; ctx.font=(Math.min(W,H)*0.03)+'px ui-monospace,Menlo'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(nb[i],x,nbY); }
    }

    // Corners
    const c = layout.corners;
    const cSpec=[{x:W*0.18,y:H*0.18,l:c[0],col:'#7bf59a'},{x:W*0.82,y:H*0.18,l:c[1],col:'#ffb3b3'},{x:W*0.5,y:H*0.18,l:c[2],col:'#9aa3b2'}];
    for(const k of cSpec){ tiles.push({x:k.x,y:k.y,r:Math.min(W,H)*0.04,label:k.l,type:'corner'});
      if(!blind){ ctx.fillStyle=k.col; ctx.font=(Math.min(W,H)*0.028)+'px ui-monospace,Menlo'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(k.l,k.x,k.y); }
    }
  }

  // ======== Planchette Physics ========
  const plan = {x:0,y:0,vx:0,vy:0, size: 54, trail:[], dwell:{tile:null,t:0}};
  const state = {running:false, sealed:false, startedAt:null, lastMove:performance.now(), microJitter:0, decisions:[], message:"", pointerLocked:false};
  let gain = 1.8; // movement amplification

  function resetAll(){ state.running=false; state.sealed=false; state.startedAt=null; stdConf').textContent='—'; centerPlanchette(); drawBoard(); drawFX(0); }

  // pointer input → smoothed target
  let target={x:0,y:0};
  function onPointer(e){ const rect=board.getBoundingClientRect(); const px=(e.clientX-rect.left)*DPR, py=(e.clientY-rect.top)*DPR; const t=performance.now();
    const dt=t-state.lastMove; state.lastMove=t; //function onPointer(e){
    if(state.pointerLocked) return; // when locked we use movementX/Y
    const rect=board.getBoundingClientRect();
    const px=(e.clientX-rect.left)*DPR, py=(e.clientY-rect.top)*DPR;
    const t=performance.now();
    const dt=t-state.lastMove; state.lastMove=t;
    const dx=(px-(target.x||px))*gain, dy=(py-(target.y||py))*gain;
    const speed=Math.hypot(dx,dy)/(dt||16);
    state.microJitter = lerp(state.microJitter, Math.min(1, speed/50), 0.12);
    target.x = (target.x||px)+dx; target.y = (target.y||py)+dy;
  }steboard.addEventListener('pointermove', onPointer);
  // high frequency raw updates where supported
  board.addEventListener('pointerrawupdate', onPointer);unction stepPhysics(dt){
    const kFollow = 0.12; // smoothing factor
    const noise = (n)=> (Math.sin((performance.now()+n*97)*0.006 + n)board.addEventListener('pointerup', e=>{tryDwellCommit(true)});
  // Pointer lock for ultra sensitivity
  function enablePointerLock(){ if(state.pointerLocked) return; if(board.requestPointerLock){ board.requestPointerLock(); }}
  document.addEventListener('pointerlockchange', ()=>{ state.pointerLocked = document.pointerLockElement === board; });
  document.addEventListener('mousemove', (e)=>{
    if(!state.pointerLocked) return;
    const t=performance.now(); const dt=t-state.lastMove; state.lastMove=t;
    const dx=(e.movementX||0)*DPR*gain, dy=(e.movementY||0)*DPR*gain;
    target.x = clamp((target.x||plan.x)+dx, 0, board.width);
    target.y = clamp((target.y||plan.y)+dy, 0, board.height);
    const speed=Math.hypot(dx,dy)/(dt||16);
    state.microJitter = lerp(state.microJitter, Math.min(1, speed/40), 0.15);
  });plify tiny involuntary drift
    const amp = 0.6 + state.microJitter*0.9;
    const nx = target.x + noise(1)*8*amp, ny = target.y + noise(2)*8*amp;
    plan.x = lerp(plan.x||nx, nx, kFollow);
    plan.y = lerp(plan.y||ny, ny, kFollow);
    // conf is simply inverse of plan speed jitter (for vibe only)
    const conf = clamp(1 - (Math.abs(noise(1))+Math.abs(noise(2)))/2, 0, 1);
    $('#hudConf').textContent = (conf*100|0)+'%';
  }

  // ======== Detection & Transcript ========
  function drawFX(dt){
    const W=fx.width,H=fx.height; gfx.clearRect(0,0,W,H);
    // trail
    gfx.strokeStyle='rgba(122,225,255,0.25)'; gfx.lineWidth=2; gfx.beginPath();
    for(let i=0;i<plan.trail.length;i++){ const p=plan.trail[i]; if(i===0) gfx.moveTo(p.x,p.y); else gfx.lineTo(p.x,p.y);} gfx.stroke();
    // planchette
    const r=plan.size*DPR*0.5; const x=plan.x, y=plan.y;
    // body
    gfx.fillStyle='rgba(15,22,34,0.9)'; gfx.strokeStyle='rgba(45,90,150,0.8)'; gfx.lineWidth=3; gfx.beginPath(); gfx.ellipse(x,y,r*1.1,r,0,0,Math.PI*2); gfx.fill(); gfx.stroke();
    // peephole
    gfx.fillStyle='rgba(255,255,255,0.06)'; gfx.beginPath(); gfx.arc(x,y,r*0.35,0,Math.PI*2); gfx.fill();
  }

  function loop(){
    const t=performance.now(); stepPhysics(16); if(state.running){ plan.trail.push({x:plan.x,y:plan.y,t}); if(plan.trail.length>1200) plan.trail.shift(); checkDwell(16);} drawFX(16); requestAnimationFrame(loop);
  }

  function hitTest(x,y){ for(const tile of tiles){ if(Math.hypot(x-tile.x,y-tile.y) <= tile.r) return tile; } return null }

  function checkDwell(dt){
    const tile = hitTest(plan.x, plan.y);
    if(tile && tile!==plan.dwell.tile){ plan.dwell={tile,t:0}; }
    if(tile){ plan.dwell.t += dt; if(plan.dwell.t>600){ commit(tile); plan.dwell={tile:null,t:0}; } }
  }

  function tryDwellCommit(force=false){ const tile = hitTest(plan.x,plan.y); if(force && tile){ commit(tile); plan.dwell={tile:null,t:0}; }}

  function commit(tile){ if(!state.running) return; const lab = tile.label; state.decisions.push({t:Date.now(),label:lab,x:tile.x,y:tile.y});
    if(lab==='YES'||lab==='NO'){ state.message += ' ['+lab+']'; }
    else if(lab==='GOODBYE'){ state.message += ' [GOODBYE]'; stopSession(); }
    else{ state.message += (lab.length===1? lab : ''); }
    $('#log').textContent = blind? '(sealed — stop to reveal)': state.message; $('#badgeLen').textContent = (state.message.replace(/\s/g,'').length)+' chars';
    pulse();
  }

  function pulse(){ gfx.save(); gfx.strokeStyle='rgba(122,225,255,0.6)'; gfx.lineWidth=6; gfx.beginPath(); gfx.arc(plan.x,plan.y,plan.size*DPR*0.58,0,Math.PI*2); gfx.stroke(); gfx.restore(); }

  // ======== Session control ========
  function startSession(){ if(state.running) return; state.running=true; state.startedAt=Date.now(); $('#hudMode').textContent='Listening'; centerPlanchette(); toast('Begin. Keep a light touch and don\'t steer.function startSession(){
    if(state.running) return;
    state.running=true; state.startedAt=Date.now();
    $('#hudMode').textContent='Listening';
    centerPlanchette();
    if($('#chkHiSens').checked) enablePointerLock();
    toast('Begin. Keep a light touch and don\'t steer.');
  }d()function stopSession(){
    if(!state.running) return;
    state.running=false; $('#hudMode').textContent='Stopped';
    if(state.pointerLocked && document.exitPointerLock){ document.exitPointerLock(); }
    if(blind){ blind=false; $('#chkBlind').checked=false; $('#hudBlind').textContent='Off'; drawBoard(); $('#log').textContent=state.message||'(no text)'; toast('Reveal'); }
  }out: layoutShuffle? 'shuffled':'classic',
      blind,
      sealed: state.sealed,
      message: state.message,
      decisions: state.decisions,
      trail: plan.trail.slice(-400),
      hash: hash32(JSON.stringify(state.message)+'/'+state.startedAt)
    };
    const blob=new Blob([JSON.stringify(body,null,2)],{type:'application/json'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`spiritboard_${body.startedAt}.json`; a.click();
  }

  // ======== Bind UI ========
  $('#btnStart').onclick=()=>startSession();
  $('#btnStop').onclick=()=>stopSession();
  $('#btnReset').onclick=()=>hardReset();
  $('#btnExport').onclick=()=>exportJSON();
  $('#chkBlind').onchange=(e)=>{ blind=e.target.checked; $('#hudBlind').textContent=blind? 'On':'Off'; drawBoard(); if(blind){ $('#log').textContent='(sealed — stop to reveal)'; }}
  $('#chkShuffle').onchange=(e)=>{ layoutShuffle=e.target.checked; makeLayout(); drawBoard(); }
  $('#chkSeal').onchange=(e)=>{ state.sealed=e.target.checked; }

  window.addEventListener('keydown',e=>{
    if(e.key===' '){ e.preventDefault(); state.running? stopSession(): startSession(); }
    if(e.key==$('#chkSeal').onchange=(e)=>{ state.sealed=e.target.checked; }
  $('#chkHiSens').onchange=(e)=>{ if(state.running && e.target.checked) enablePointerLock(); else if(!e.target.checked && document.exitPointerLock){ document.exitPointerLock(); }}
  $('#rngGain').oninput=(e)=>{ gain = parseFloat(e.target.value||'1.8'); }blind=!blind; $('#chkBlind').checked=blind; $('#hudBlind').textContent=blind? 'On':'Off'; drawBoard(); if(blind) $('#log').textContent='(sealed — stop to reveal)'; }
    if(e.key.toLowerCase()==='s'){ layoutShuffle=!layoutShuffle; $('#chkShuffle').checked=layoutShuffle; makeLayout(); drawBoard(); toast(layoutShuffle? 'Shuffled layout':'Classic layout'); }
  });

  // ======== Boot ========
  makeLayout(); resize(); centerPlanchette(); resetAll(); // ensure FX overlay never steals events
  try{ document.getElementById('fx').style.pointerEvents='none'; }catch(e){}
  loop();
})();
</script>
</body>
</html>

