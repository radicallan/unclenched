<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>IsoHotel Engine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
            font-family: 'Verdana', sans-serif; /* The classic Habbo font */
            image-rendering: pixelated; /* Crisp edges */
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
            text-align: center;
            border: 2px solid #fff;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .highlight { color: #f7eb05; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui">
    Welcome to <span class="highlight">IsoHotel</span>.<br>
    <small>Click to Move • Logic runs at 60FPS • Procedural Graphics</small>
</div>
<canvas id="gameCanvas"></canvas>

<script>
/**
 * ISOHOTEL ENGINE
 * A minimal, high-performance isometric engine written from scratch.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONFIGURATION ---
const TILE_WIDTH = 64;
const TILE_HEIGHT = 32; // Standard 2:1 Iso Ratio
const MAP_SIZE = 12;
const COLORS = {
    floor: '#95a5a6',
    floorDark: '#7f8c8d',
    wallLeft: '#bdc3c7',
    wallRight: '#95a5a6',
    wallTop: '#ecf0f1',
    highlight: 'rgba(255, 255, 255, 0.3)',
    shadow: 'rgba(0,0,0,0.2)'
};

// --- STATE MANAGEMENT ---
let width, height;
let cameraX = 0;
let cameraY = 100;
let mouse = { x: 0, y: 0, gridX: -1, gridY: -1 };
let frameCount = 0;

// The World Map (0: Floor, 1: Wall)
const map = [];
for(let x=0; x<MAP_SIZE; x++) {
    map[x] = [];
    for(let y=0; y<MAP_SIZE; y++) {
        // Create simple walls on edges
        if (x === 0 || y === 0) map[x][y] = 1; 
        else map[x][y] = 0;
    }
}

// --- ENTITIES ---
class Entity {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.z = 0; // Height off ground
        this.targetX = x;
        this.targetY = y;
        this.color = color;
        this.speed = 0.15;
        this.chat = null;
        this.chatTimer = 0;
        this.height = 40; // Pixel height of sprite
    }

    update() {
        // Smooth interpolation movement
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        
        if (Math.abs(dx) > 0.05) this.x += dx * this.speed;
        else this.x = this.targetX;
        
        if (Math.abs(dy) > 0.05) this.y += dy * this.speed;
        else this.y = this.targetY;

        // Bobbing animation for idle
        if(Math.abs(dx) < 0.01 && Math.abs(dy) < 0.01) {
            this.z = Math.sin(frameCount * 0.1) * 2;
        } else {
            // Walking hop
            this.z = Math.abs(Math.sin(frameCount * 0.5)) * 5;
        }

        if (this.chatTimer > 0) this.chatTimer--;
        else this.chat = null;
    }

    say(text) {
        this.chat = text;
        this.chatTimer = 180; // 3 seconds
    }
}

// Create Player and some Furni
const player = new Entity(5, 5, '#e74c3c'); // Red guy
const furniture = [
    { x: 3, y: 3, type: 'plant' },
    { x: 8, y: 4, type: 'table' },
    { x: 8, y: 5, type: 'table' },
    { x: 2, y: 8, type: 'lamp' }
];

// --- ISOMETRIC MATH ---
// Converts Grid Coordinates (3D) to Screen Coordinates (2D)
function isoToScreen(x, y, z) {
    return {
        x: (x - y) * TILE_WIDTH / 2 + width / 2 - cameraX,
        y: (x + y) * TILE_HEIGHT / 2 - (z * TILE_HEIGHT) + height / 2 - cameraY
    };
}

// Converts Screen Coordinates to Grid Coordinates (Inverse Matrix)
function screenToIso(sx, sy) {
    let adjX = sx - width / 2 + cameraX;
    let adjY = sy - height / 2 + cameraY;
    return {
        x: Math.floor((adjY / (TILE_HEIGHT/2) + adjX / (TILE_WIDTH/2)) / 2),
        y: Math.floor((adjY / (TILE_HEIGHT/2) - adjX / (TILE_WIDTH/2)) / 2)
    };
}

// --- RENDERING HELPERS ---
function drawBlock(x, y, z, w, h, colorBase, heightPx) {
    const pos = isoToScreen(x, y, z);
    const topX = pos.x;
    const topY = pos.y - heightPx;

    ctx.lineWidth = 1;
    ctx.lineJoin = 'round';

    // Right Face
    ctx.fillStyle = shadeColor(colorBase, -20);
    ctx.beginPath();
    ctx.moveTo(topX, topY + h/2);
    ctx.lineTo(topX + w/2, topY);
    ctx.lineTo(topX + w/2, topY + heightPx);
    ctx.lineTo(topX, topY + h/2 + heightPx);
    ctx.fill();

    // Left Face
    ctx.fillStyle = shadeColor(colorBase, -10);
    ctx.beginPath();
    ctx.moveTo(topX, topY + h/2);
    ctx.lineTo(topX - w/2, topY);
    ctx.lineTo(topX - w/2, topY + heightPx);
    ctx.lineTo(topX, topY + h/2 + heightPx);
    ctx.fill();

    // Top Face
    ctx.fillStyle = colorBase;
    ctx.beginPath();
    ctx.moveTo(topX, topY - h/2); // Top tip
    ctx.lineTo(topX + w/2, topY); // Right tip
    ctx.lineTo(topX, topY + h/2); // Bottom tip
    ctx.lineTo(topX - w/2, topY); // Left tip
    ctx.closePath();
    ctx.fill();
    
    // Highlight Edge
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.stroke();
}

function drawTile(x, y, type) {
    const pos = isoToScreen(x, y, 0);
    
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y - TILE_HEIGHT/2);
    ctx.lineTo(pos.x + TILE_WIDTH/2, pos.y);
    ctx.lineTo(pos.x, pos.y + TILE_HEIGHT/2);
    ctx.lineTo(pos.x - TILE_WIDTH/2, pos.y);
    ctx.closePath();

    if (type === 1) { // Wall
        // Draw Wall Column
        drawBlock(x, y, 0, TILE_WIDTH, TILE_HEIGHT, '#bdc3c7', 80);
    } else {
        // Floor
        ctx.fillStyle = (x + y) % 2 === 0 ? COLORS.floor : COLORS.floorDark;
        ctx.fill();
        
        // Mouse Hover Highlight
        if (mouse.gridX === x && mouse.gridY === y) {
            ctx.fillStyle = COLORS.highlight;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
}

function drawShadow(x, y) {
    const pos = isoToScreen(x, y, 0);
    ctx.fillStyle = COLORS.shadow;
    ctx.beginPath();
    ctx.ellipse(pos.x, pos.y, TILE_WIDTH/3, TILE_HEIGHT/3, 0, 0, Math.PI * 2);
    ctx.fill();
}

function drawAvatar(entity) {
    const pos = isoToScreen(entity.x, entity.y, 0);
    const spriteY = pos.y - entity.z - 10;

    // Shadow
    drawShadow(entity.x, entity.y);

    // Procedural Avatar Drawing
    // Body
    ctx.fillStyle = entity.color;
    ctx.fillRect(pos.x - 10, spriteY - 30, 20, 30);
    
    // Head
    ctx.fillStyle = '#f1c40f'; // Skin
    ctx.fillRect(pos.x - 8, spriteY - 44, 16, 16);
    
    // Hair
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(pos.x - 9, spriteY - 46, 18, 6);

    // Legs (Simple animation)
    ctx.fillStyle = '#34495e';
    let legOffset = Math.sin(frameCount * 0.5) * 5;
    ctx.fillRect(pos.x - 9, spriteY - 5, 6, 12 + legOffset);
    ctx.fillRect(pos.x + 3, spriteY - 5, 6, 12 - legOffset);

    // Chat Bubble
    if (entity.chat) {
        ctx.font = "12px Verdana";
        const w = ctx.measureText(entity.chat).width + 10;
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.roundRect(pos.x - w/2, spriteY - 70, w, 20, 5);
        ctx.fill();
        
        // Triangle tail
        ctx.beginPath();
        ctx.moveTo(pos.x, spriteY - 50);
        ctx.lineTo(pos.x - 5, spriteY - 51);
        ctx.lineTo(pos.x + 5, spriteY - 51);
        ctx.fill();

        ctx.fillStyle = "black";
        ctx.fillText(entity.chat, pos.x - w/2 + 5, spriteY - 56);
    }
}

function drawFurni(item) {
    if (item.type === 'plant') {
        drawBlock(item.x, item.y, 0, 20, 10, '#8e44ad', 20); // Pot
        drawBlock(item.x, item.y, 0.5, 10, 5, '#2ecc71', 40); // Plant
    } else if (item.type === 'table') {
        drawBlock(item.x, item.y, 0, 10, 5, '#7f8c8d', 20); // Leg
        drawBlock(item.x, item.y, 0.6, TILE_WIDTH, TILE_HEIGHT, '#34495e', 5); // Top
    } else if (item.type === 'lamp') {
        drawBlock(item.x, item.y, 0, 10, 5, '#f39c12', 50); // Base
        
        // Light glow
        const pos = isoToScreen(item.x, item.y, 1.5);
        const grad = ctx.createRadialGradient(pos.x, pos.y, 5, pos.x, pos.y, 40);
        grad.addColorStop(0, "rgba(255, 255, 200, 0.8)");
        grad.addColorStop(1, "rgba(255, 255, 200, 0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 40, 0, Math.PI*2);
        ctx.fill();
    }
}

// Utility: Lighten/Darken hex color
function shadeColor(color, percent) {
    var R = parseInt(color.substring(1,3),16);
    var G = parseInt(color.substring(3,5),16);
    var B = parseInt(color.substring(5,7),16);
    R = parseInt(R * (100 + percent) / 100);
    G = parseInt(G * (100 + percent) / 100);
    B = parseInt(B * (100 + percent) / 100);
    R = (R<255)?R:255;  
    G = (G<255)?G:255;  
    B = (B<255)?B:255;  
    var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
    var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
    var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
    return "#"+RR+GG+BB;
}

// --- CORE LOOP ---
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}

function update() {
    frameCount++;
    player.update();
}

function draw() {
    // 1. Clear Screen
    const grad = ctx.createLinearGradient(0, 0, 0, height);
    grad.addColorStop(0, "#2c3e50");
    grad.addColorStop(1, "#000000");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);

    // 2. Prepare Render List (Depth Sorting)
    let renderList = [];

    // Add Tiles
    for(let x=0; x<MAP_SIZE; x++) {
        for(let y=0; y<MAP_SIZE; y++) {
            renderList.push({ type: 'tile', x: x, y: y, z: 0, sortDepth: x + y });
        }
    }

    // Add Furniture
    furniture.forEach(f => {
        renderList.push({ type: 'furni', obj: f, x: f.x, y: f.y, z: 0, sortDepth: f.x + f.y + 0.5 }); // +0.5 to sit on top of tiles
    });

    // Add Player
    renderList.push({ type: 'player', x: Math.round(player.x), y: Math.round(player.y), sortDepth: player.x + player.y + 0.6 });

    // 3. Sort by Depth (Painter's Algorithm)
    renderList.sort((a, b) => a.sortDepth - b.sortDepth);

    // 4. Draw Everything
    renderList.forEach(item => {
        if (item.type === 'tile') {
            drawTile(item.x, item.y, map[item.x][item.y]);
        } else if (item.type === 'furni') {
            drawFurni(item.obj);
        } else if (item.type === 'player') {
            drawAvatar(player);
        }
    });
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// --- INPUT HANDLING ---
window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    const gridPos = screenToIso(mouse.x, mouse.y);
    mouse.gridX = gridPos.x;
    mouse.gridY = gridPos.y;
});

window.addEventListener('mousedown', () => {
    // Check bounds
    if (mouse.gridX >= 0 && mouse.gridX < MAP_SIZE && mouse.gridY >= 0 && mouse.gridY < MAP_SIZE) {
        // Simple collision check (Walls)
        if (map[mouse.gridX][mouse.gridY] !== 1) {
            player.targetX = mouse.gridX;
            player.targetY = mouse.gridY;
            
            // Random Habbo-style phrase
            const phrases = ["Going there!", "On my way.", "Bobba bobba.", "Nice pixel art!", "Walk walk walk"];
            if (Math.random() > 0.7) {
                player.say(phrases[Math.floor(Math.random() * phrases.length)]);
            }
        } else {
            player.say("Can't walk there!");
        }
    }
});

// Start
resize();
loop();

</script>
</body>
</html>
